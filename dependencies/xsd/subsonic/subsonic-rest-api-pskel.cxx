// Copyright (C) 2005-2010 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

// Begin prologue.
//
//
// End prologue.

#include "subsonic-rest-api-pskel.hxx"

namespace restapi
{
  // Response_pskel
  //

  void Response_pskel::
  musicFolders_parser (::restapi::MusicFolders_pskel& p)
  {
    this->musicFolders_parser_ = &p;
  }

  void Response_pskel::
  indexes_parser (::restapi::Indexes_pskel& p)
  {
    this->indexes_parser_ = &p;
  }

  void Response_pskel::
  directory_parser (::restapi::Directory_pskel& p)
  {
    this->directory_parser_ = &p;
  }

  void Response_pskel::
  genres_parser (::restapi::Genres_pskel& p)
  {
    this->genres_parser_ = &p;
  }

  void Response_pskel::
  artists_parser (::restapi::ArtistsID3_pskel& p)
  {
    this->artists_parser_ = &p;
  }

  void Response_pskel::
  artist_parser (::restapi::ArtistWithAlbumsID3_pskel& p)
  {
    this->artist_parser_ = &p;
  }

  void Response_pskel::
  album_parser (::restapi::AlbumWithSongsID3_pskel& p)
  {
    this->album_parser_ = &p;
  }

  void Response_pskel::
  song_parser (::restapi::Child_pskel& p)
  {
    this->song_parser_ = &p;
  }

  void Response_pskel::
  videos_parser (::restapi::Videos_pskel& p)
  {
    this->videos_parser_ = &p;
  }

  void Response_pskel::
  nowPlaying_parser (::restapi::NowPlaying_pskel& p)
  {
    this->nowPlaying_parser_ = &p;
  }

  void Response_pskel::
  searchResult_parser (::restapi::SearchResult_pskel& p)
  {
    this->searchResult_parser_ = &p;
  }

  void Response_pskel::
  searchResult2_parser (::restapi::SearchResult2_pskel& p)
  {
    this->searchResult2_parser_ = &p;
  }

  void Response_pskel::
  searchResult3_parser (::restapi::SearchResult3_pskel& p)
  {
    this->searchResult3_parser_ = &p;
  }

  void Response_pskel::
  playlists_parser (::restapi::Playlists_pskel& p)
  {
    this->playlists_parser_ = &p;
  }

  void Response_pskel::
  playlist_parser (::restapi::PlaylistWithSongs_pskel& p)
  {
    this->playlist_parser_ = &p;
  }

  void Response_pskel::
  jukeboxStatus_parser (::restapi::JukeboxStatus_pskel& p)
  {
    this->jukeboxStatus_parser_ = &p;
  }

  void Response_pskel::
  jukeboxPlaylist_parser (::restapi::JukeboxPlaylist_pskel& p)
  {
    this->jukeboxPlaylist_parser_ = &p;
  }

  void Response_pskel::
  license_parser (::restapi::License_pskel& p)
  {
    this->license_parser_ = &p;
  }

  void Response_pskel::
  users_parser (::restapi::Users_pskel& p)
  {
    this->users_parser_ = &p;
  }

  void Response_pskel::
  user_parser (::restapi::User_pskel& p)
  {
    this->user_parser_ = &p;
  }

  void Response_pskel::
  chatMessages_parser (::restapi::ChatMessages_pskel& p)
  {
    this->chatMessages_parser_ = &p;
  }

  void Response_pskel::
  albumList_parser (::restapi::AlbumList_pskel& p)
  {
    this->albumList_parser_ = &p;
  }

  void Response_pskel::
  albumList2_parser (::restapi::AlbumList2_pskel& p)
  {
    this->albumList2_parser_ = &p;
  }

  void Response_pskel::
  randomSongs_parser (::restapi::Songs_pskel& p)
  {
    this->randomSongs_parser_ = &p;
  }

  void Response_pskel::
  songsByGenre_parser (::restapi::Songs_pskel& p)
  {
    this->songsByGenre_parser_ = &p;
  }

  void Response_pskel::
  lyrics_parser (::restapi::Lyrics_pskel& p)
  {
    this->lyrics_parser_ = &p;
  }

  void Response_pskel::
  podcasts_parser (::restapi::Podcasts_pskel& p)
  {
    this->podcasts_parser_ = &p;
  }

  void Response_pskel::
  internetRadioStations_parser (::restapi::InternetRadioStations_pskel& p)
  {
    this->internetRadioStations_parser_ = &p;
  }

  void Response_pskel::
  bookmarks_parser (::restapi::Bookmarks_pskel& p)
  {
    this->bookmarks_parser_ = &p;
  }

  void Response_pskel::
  shares_parser (::restapi::Shares_pskel& p)
  {
    this->shares_parser_ = &p;
  }

  void Response_pskel::
  starred_parser (::restapi::Starred_pskel& p)
  {
    this->starred_parser_ = &p;
  }

  void Response_pskel::
  starred2_parser (::restapi::Starred2_pskel& p)
  {
    this->starred2_parser_ = &p;
  }

  void Response_pskel::
  error_parser (::restapi::Error_pskel& p)
  {
    this->error_parser_ = &p;
  }

  void Response_pskel::
  status_parser (::restapi::ResponseStatus_pskel& p)
  {
    this->status_parser_ = &p;
  }

  void Response_pskel::
  version_parser (::restapi::Version_pskel& p)
  {
    this->version_parser_ = &p;
  }

  void Response_pskel::
  parsers (::restapi::MusicFolders_pskel& musicFolders,
           ::restapi::Indexes_pskel& indexes,
           ::restapi::Directory_pskel& directory,
           ::restapi::Genres_pskel& genres,
           ::restapi::ArtistsID3_pskel& artists,
           ::restapi::ArtistWithAlbumsID3_pskel& artist,
           ::restapi::AlbumWithSongsID3_pskel& album,
           ::restapi::Child_pskel& song,
           ::restapi::Videos_pskel& videos,
           ::restapi::NowPlaying_pskel& nowPlaying,
           ::restapi::SearchResult_pskel& searchResult,
           ::restapi::SearchResult2_pskel& searchResult2,
           ::restapi::SearchResult3_pskel& searchResult3,
           ::restapi::Playlists_pskel& playlists,
           ::restapi::PlaylistWithSongs_pskel& playlist,
           ::restapi::JukeboxStatus_pskel& jukeboxStatus,
           ::restapi::JukeboxPlaylist_pskel& jukeboxPlaylist,
           ::restapi::License_pskel& license,
           ::restapi::Users_pskel& users,
           ::restapi::User_pskel& user,
           ::restapi::ChatMessages_pskel& chatMessages,
           ::restapi::AlbumList_pskel& albumList,
           ::restapi::AlbumList2_pskel& albumList2,
           ::restapi::Songs_pskel& randomSongs,
           ::restapi::Songs_pskel& songsByGenre,
           ::restapi::Lyrics_pskel& lyrics,
           ::restapi::Podcasts_pskel& podcasts,
           ::restapi::InternetRadioStations_pskel& internetRadioStations,
           ::restapi::Bookmarks_pskel& bookmarks,
           ::restapi::Shares_pskel& shares,
           ::restapi::Starred_pskel& starred,
           ::restapi::Starred2_pskel& starred2,
           ::restapi::Error_pskel& error,
           ::restapi::ResponseStatus_pskel& status,
           ::restapi::Version_pskel& version)
  {
    this->musicFolders_parser_ = &musicFolders;
    this->indexes_parser_ = &indexes;
    this->directory_parser_ = &directory;
    this->genres_parser_ = &genres;
    this->artists_parser_ = &artists;
    this->artist_parser_ = &artist;
    this->album_parser_ = &album;
    this->song_parser_ = &song;
    this->videos_parser_ = &videos;
    this->nowPlaying_parser_ = &nowPlaying;
    this->searchResult_parser_ = &searchResult;
    this->searchResult2_parser_ = &searchResult2;
    this->searchResult3_parser_ = &searchResult3;
    this->playlists_parser_ = &playlists;
    this->playlist_parser_ = &playlist;
    this->jukeboxStatus_parser_ = &jukeboxStatus;
    this->jukeboxPlaylist_parser_ = &jukeboxPlaylist;
    this->license_parser_ = &license;
    this->users_parser_ = &users;
    this->user_parser_ = &user;
    this->chatMessages_parser_ = &chatMessages;
    this->albumList_parser_ = &albumList;
    this->albumList2_parser_ = &albumList2;
    this->randomSongs_parser_ = &randomSongs;
    this->songsByGenre_parser_ = &songsByGenre;
    this->lyrics_parser_ = &lyrics;
    this->podcasts_parser_ = &podcasts;
    this->internetRadioStations_parser_ = &internetRadioStations;
    this->bookmarks_parser_ = &bookmarks;
    this->shares_parser_ = &shares;
    this->starred_parser_ = &starred;
    this->starred2_parser_ = &starred2;
    this->error_parser_ = &error;
    this->status_parser_ = &status;
    this->version_parser_ = &version;
  }

  Response_pskel::
  Response_pskel ()
  : musicFolders_parser_ (0),
    indexes_parser_ (0),
    directory_parser_ (0),
    genres_parser_ (0),
    artists_parser_ (0),
    artist_parser_ (0),
    album_parser_ (0),
    song_parser_ (0),
    videos_parser_ (0),
    nowPlaying_parser_ (0),
    searchResult_parser_ (0),
    searchResult2_parser_ (0),
    searchResult3_parser_ (0),
    playlists_parser_ (0),
    playlist_parser_ (0),
    jukeboxStatus_parser_ (0),
    jukeboxPlaylist_parser_ (0),
    license_parser_ (0),
    users_parser_ (0),
    user_parser_ (0),
    chatMessages_parser_ (0),
    albumList_parser_ (0),
    albumList2_parser_ (0),
    randomSongs_parser_ (0),
    songsByGenre_parser_ (0),
    lyrics_parser_ (0),
    podcasts_parser_ (0),
    internetRadioStations_parser_ (0),
    bookmarks_parser_ (0),
    shares_parser_ (0),
    starred_parser_ (0),
    starred2_parser_ (0),
    error_parser_ (0),
    status_parser_ (0),
    version_parser_ (0),
    v_state_stack_ (sizeof (v_state_), &v_state_first_),
    v_state_attr_stack_ (sizeof (v_state_attr_), &v_state_attr_first_)
  {
  }

  // MusicFolders_pskel
  //

  void MusicFolders_pskel::
  musicFolder_parser (::restapi::MusicFolder_pskel& p)
  {
    this->musicFolder_parser_ = &p;
  }

  void MusicFolders_pskel::
  parsers (::restapi::MusicFolder_pskel& musicFolder)
  {
    this->musicFolder_parser_ = &musicFolder;
  }

  MusicFolders_pskel::
  MusicFolders_pskel ()
  : musicFolder_parser_ (0),
    v_state_stack_ (sizeof (v_state_), &v_state_first_)
  {
  }

  // MusicFolder_pskel
  //

  void MusicFolder_pskel::
  id_parser (::xml_schema::int_pskel& p)
  {
    this->id_parser_ = &p;
  }

  void MusicFolder_pskel::
  name_parser (::xml_schema::string_pskel& p)
  {
    this->name_parser_ = &p;
  }

  void MusicFolder_pskel::
  parsers (::xml_schema::int_pskel& id,
           ::xml_schema::string_pskel& name)
  {
    this->id_parser_ = &id;
    this->name_parser_ = &name;
  }

  MusicFolder_pskel::
  MusicFolder_pskel ()
  : id_parser_ (0),
    name_parser_ (0),
    v_state_attr_stack_ (sizeof (v_state_attr_), &v_state_attr_first_)
  {
  }

  // Indexes_pskel
  //

  void Indexes_pskel::
  shortcut_parser (::restapi::Artist_pskel& p)
  {
    this->shortcut_parser_ = &p;
  }

  void Indexes_pskel::
  index_parser (::restapi::Index_pskel& p)
  {
    this->index_parser_ = &p;
  }

  void Indexes_pskel::
  child_parser (::restapi::Child_pskel& p)
  {
    this->child_parser_ = &p;
  }

  void Indexes_pskel::
  lastModified_parser (::xml_schema::long_pskel& p)
  {
    this->lastModified_parser_ = &p;
  }

  void Indexes_pskel::
  ignoredArticles_parser (::xml_schema::string_pskel& p)
  {
    this->ignoredArticles_parser_ = &p;
  }

  void Indexes_pskel::
  parsers (::restapi::Artist_pskel& shortcut,
           ::restapi::Index_pskel& index,
           ::restapi::Child_pskel& child,
           ::xml_schema::long_pskel& lastModified,
           ::xml_schema::string_pskel& ignoredArticles)
  {
    this->shortcut_parser_ = &shortcut;
    this->index_parser_ = &index;
    this->child_parser_ = &child;
    this->lastModified_parser_ = &lastModified;
    this->ignoredArticles_parser_ = &ignoredArticles;
  }

  Indexes_pskel::
  Indexes_pskel ()
  : shortcut_parser_ (0),
    index_parser_ (0),
    child_parser_ (0),
    lastModified_parser_ (0),
    ignoredArticles_parser_ (0),
    v_state_stack_ (sizeof (v_state_), &v_state_first_),
    v_state_attr_stack_ (sizeof (v_state_attr_), &v_state_attr_first_)
  {
  }

  // Index_pskel
  //

  void Index_pskel::
  artist_parser (::restapi::Artist_pskel& p)
  {
    this->artist_parser_ = &p;
  }

  void Index_pskel::
  name_parser (::xml_schema::string_pskel& p)
  {
    this->name_parser_ = &p;
  }

  void Index_pskel::
  parsers (::restapi::Artist_pskel& artist,
           ::xml_schema::string_pskel& name)
  {
    this->artist_parser_ = &artist;
    this->name_parser_ = &name;
  }

  Index_pskel::
  Index_pskel ()
  : artist_parser_ (0),
    name_parser_ (0),
    v_state_stack_ (sizeof (v_state_), &v_state_first_),
    v_state_attr_stack_ (sizeof (v_state_attr_), &v_state_attr_first_)
  {
  }

  // Artist_pskel
  //

  void Artist_pskel::
  id_parser (::xml_schema::string_pskel& p)
  {
    this->id_parser_ = &p;
  }

  void Artist_pskel::
  name_parser (::xml_schema::string_pskel& p)
  {
    this->name_parser_ = &p;
  }

  void Artist_pskel::
  starred_parser (::xml_schema::date_time_pskel& p)
  {
    this->starred_parser_ = &p;
  }

  void Artist_pskel::
  parsers (::xml_schema::string_pskel& id,
           ::xml_schema::string_pskel& name,
           ::xml_schema::date_time_pskel& starred)
  {
    this->id_parser_ = &id;
    this->name_parser_ = &name;
    this->starred_parser_ = &starred;
  }

  Artist_pskel::
  Artist_pskel ()
  : id_parser_ (0),
    name_parser_ (0),
    starred_parser_ (0),
    v_state_attr_stack_ (sizeof (v_state_attr_), &v_state_attr_first_)
  {
  }

  // Genres_pskel
  //

  void Genres_pskel::
  genre_parser (::restapi::Genre_pskel& p)
  {
    this->genre_parser_ = &p;
  }

  void Genres_pskel::
  parsers (::restapi::Genre_pskel& genre)
  {
    this->genre_parser_ = &genre;
  }

  Genres_pskel::
  Genres_pskel ()
  : genre_parser_ (0),
    v_state_stack_ (sizeof (v_state_), &v_state_first_)
  {
  }

  // Genre_pskel
  //

  void Genre_pskel::
  songCount_parser (::xml_schema::int_pskel& p)
  {
    this->songCount_parser_ = &p;
  }

  void Genre_pskel::
  albumCount_parser (::xml_schema::int_pskel& p)
  {
    this->albumCount_parser_ = &p;
  }

  void Genre_pskel::
  parsers (::xml_schema::int_pskel& songCount,
           ::xml_schema::int_pskel& albumCount)
  {
    this->songCount_parser_ = &songCount;
    this->albumCount_parser_ = &albumCount;
  }

  Genre_pskel::
  Genre_pskel ()
  : songCount_parser_ (0),
    albumCount_parser_ (0),
    v_state_attr_stack_ (sizeof (v_state_attr_), &v_state_attr_first_)
  {
  }

  // ArtistsID3_pskel
  //

  void ArtistsID3_pskel::
  index_parser (::restapi::IndexID3_pskel& p)
  {
    this->index_parser_ = &p;
  }

  void ArtistsID3_pskel::
  ignoredArticles_parser (::xml_schema::string_pskel& p)
  {
    this->ignoredArticles_parser_ = &p;
  }

  void ArtistsID3_pskel::
  parsers (::restapi::IndexID3_pskel& index,
           ::xml_schema::string_pskel& ignoredArticles)
  {
    this->index_parser_ = &index;
    this->ignoredArticles_parser_ = &ignoredArticles;
  }

  ArtistsID3_pskel::
  ArtistsID3_pskel ()
  : index_parser_ (0),
    ignoredArticles_parser_ (0),
    v_state_stack_ (sizeof (v_state_), &v_state_first_),
    v_state_attr_stack_ (sizeof (v_state_attr_), &v_state_attr_first_)
  {
  }

  // IndexID3_pskel
  //

  void IndexID3_pskel::
  artist_parser (::restapi::ArtistID3_pskel& p)
  {
    this->artist_parser_ = &p;
  }

  void IndexID3_pskel::
  name_parser (::xml_schema::string_pskel& p)
  {
    this->name_parser_ = &p;
  }

  void IndexID3_pskel::
  parsers (::restapi::ArtistID3_pskel& artist,
           ::xml_schema::string_pskel& name)
  {
    this->artist_parser_ = &artist;
    this->name_parser_ = &name;
  }

  IndexID3_pskel::
  IndexID3_pskel ()
  : artist_parser_ (0),
    name_parser_ (0),
    v_state_stack_ (sizeof (v_state_), &v_state_first_),
    v_state_attr_stack_ (sizeof (v_state_attr_), &v_state_attr_first_)
  {
  }

  // ArtistID3_pskel
  //

  void ArtistID3_pskel::
  id_parser (::xml_schema::string_pskel& p)
  {
    this->id_parser_ = &p;
  }

  void ArtistID3_pskel::
  name_parser (::xml_schema::string_pskel& p)
  {
    this->name_parser_ = &p;
  }

  void ArtistID3_pskel::
  coverArt_parser (::xml_schema::string_pskel& p)
  {
    this->coverArt_parser_ = &p;
  }

  void ArtistID3_pskel::
  albumCount_parser (::xml_schema::int_pskel& p)
  {
    this->albumCount_parser_ = &p;
  }

  void ArtistID3_pskel::
  starred_parser (::xml_schema::date_time_pskel& p)
  {
    this->starred_parser_ = &p;
  }

  void ArtistID3_pskel::
  parsers (::xml_schema::string_pskel& id,
           ::xml_schema::string_pskel& name,
           ::xml_schema::string_pskel& coverArt,
           ::xml_schema::int_pskel& albumCount,
           ::xml_schema::date_time_pskel& starred)
  {
    this->id_parser_ = &id;
    this->name_parser_ = &name;
    this->coverArt_parser_ = &coverArt;
    this->albumCount_parser_ = &albumCount;
    this->starred_parser_ = &starred;
  }

  ArtistID3_pskel::
  ArtistID3_pskel ()
  : id_parser_ (0),
    name_parser_ (0),
    coverArt_parser_ (0),
    albumCount_parser_ (0),
    starred_parser_ (0),
    v_state_attr_stack_ (sizeof (v_state_attr_), &v_state_attr_first_)
  {
  }

  // ArtistWithAlbumsID3_pskel
  //

  void ArtistWithAlbumsID3_pskel::
  album_parser (::restapi::AlbumID3_pskel& p)
  {
    this->album_parser_ = &p;
  }

  void ArtistWithAlbumsID3_pskel::
  parsers (::xml_schema::string_pskel& id,
           ::xml_schema::string_pskel& name,
           ::xml_schema::string_pskel& coverArt,
           ::xml_schema::int_pskel& albumCount,
           ::xml_schema::date_time_pskel& starred,
           ::restapi::AlbumID3_pskel& album)
  {
    this->id_parser_ = &id;
    this->name_parser_ = &name;
    this->coverArt_parser_ = &coverArt;
    this->albumCount_parser_ = &albumCount;
    this->starred_parser_ = &starred;
    this->album_parser_ = &album;
  }

  ArtistWithAlbumsID3_pskel::
  ArtistWithAlbumsID3_pskel ()
  : album_parser_ (0),
    v_state_stack_ (sizeof (v_state_), &v_state_first_)
  {
  }

  // AlbumID3_pskel
  //

  void AlbumID3_pskel::
  id_parser (::xml_schema::string_pskel& p)
  {
    this->id_parser_ = &p;
  }

  void AlbumID3_pskel::
  name_parser (::xml_schema::string_pskel& p)
  {
    this->name_parser_ = &p;
  }

  void AlbumID3_pskel::
  artist_parser (::xml_schema::string_pskel& p)
  {
    this->artist_parser_ = &p;
  }

  void AlbumID3_pskel::
  artistId_parser (::xml_schema::string_pskel& p)
  {
    this->artistId_parser_ = &p;
  }

  void AlbumID3_pskel::
  coverArt_parser (::xml_schema::string_pskel& p)
  {
    this->coverArt_parser_ = &p;
  }

  void AlbumID3_pskel::
  songCount_parser (::xml_schema::int_pskel& p)
  {
    this->songCount_parser_ = &p;
  }

  void AlbumID3_pskel::
  duration_parser (::xml_schema::int_pskel& p)
  {
    this->duration_parser_ = &p;
  }

  void AlbumID3_pskel::
  created_parser (::xml_schema::date_time_pskel& p)
  {
    this->created_parser_ = &p;
  }

  void AlbumID3_pskel::
  starred_parser (::xml_schema::date_time_pskel& p)
  {
    this->starred_parser_ = &p;
  }

  void AlbumID3_pskel::
  year_parser (::xml_schema::int_pskel& p)
  {
    this->year_parser_ = &p;
  }

  void AlbumID3_pskel::
  genre_parser (::xml_schema::string_pskel& p)
  {
    this->genre_parser_ = &p;
  }

  void AlbumID3_pskel::
  parsers (::xml_schema::string_pskel& id,
           ::xml_schema::string_pskel& name,
           ::xml_schema::string_pskel& artist,
           ::xml_schema::string_pskel& artistId,
           ::xml_schema::string_pskel& coverArt,
           ::xml_schema::int_pskel& songCount,
           ::xml_schema::int_pskel& duration,
           ::xml_schema::date_time_pskel& created,
           ::xml_schema::date_time_pskel& starred,
           ::xml_schema::int_pskel& year,
           ::xml_schema::string_pskel& genre)
  {
    this->id_parser_ = &id;
    this->name_parser_ = &name;
    this->artist_parser_ = &artist;
    this->artistId_parser_ = &artistId;
    this->coverArt_parser_ = &coverArt;
    this->songCount_parser_ = &songCount;
    this->duration_parser_ = &duration;
    this->created_parser_ = &created;
    this->starred_parser_ = &starred;
    this->year_parser_ = &year;
    this->genre_parser_ = &genre;
  }

  AlbumID3_pskel::
  AlbumID3_pskel ()
  : id_parser_ (0),
    name_parser_ (0),
    artist_parser_ (0),
    artistId_parser_ (0),
    coverArt_parser_ (0),
    songCount_parser_ (0),
    duration_parser_ (0),
    created_parser_ (0),
    starred_parser_ (0),
    year_parser_ (0),
    genre_parser_ (0),
    v_state_attr_stack_ (sizeof (v_state_attr_), &v_state_attr_first_)
  {
  }

  // AlbumWithSongsID3_pskel
  //

  void AlbumWithSongsID3_pskel::
  song_parser (::restapi::Child_pskel& p)
  {
    this->song_parser_ = &p;
  }

  void AlbumWithSongsID3_pskel::
  parsers (::xml_schema::string_pskel& id,
           ::xml_schema::string_pskel& name,
           ::xml_schema::string_pskel& artist,
           ::xml_schema::string_pskel& artistId,
           ::xml_schema::string_pskel& coverArt,
           ::xml_schema::int_pskel& songCount,
           ::xml_schema::int_pskel& duration,
           ::xml_schema::date_time_pskel& created,
           ::xml_schema::date_time_pskel& starred,
           ::xml_schema::int_pskel& year,
           ::xml_schema::string_pskel& genre,
           ::restapi::Child_pskel& song)
  {
    this->id_parser_ = &id;
    this->name_parser_ = &name;
    this->artist_parser_ = &artist;
    this->artistId_parser_ = &artistId;
    this->coverArt_parser_ = &coverArt;
    this->songCount_parser_ = &songCount;
    this->duration_parser_ = &duration;
    this->created_parser_ = &created;
    this->starred_parser_ = &starred;
    this->year_parser_ = &year;
    this->genre_parser_ = &genre;
    this->song_parser_ = &song;
  }

  AlbumWithSongsID3_pskel::
  AlbumWithSongsID3_pskel ()
  : song_parser_ (0),
    v_state_stack_ (sizeof (v_state_), &v_state_first_)
  {
  }

  // Videos_pskel
  //

  void Videos_pskel::
  video_parser (::restapi::Child_pskel& p)
  {
    this->video_parser_ = &p;
  }

  void Videos_pskel::
  parsers (::restapi::Child_pskel& video)
  {
    this->video_parser_ = &video;
  }

  Videos_pskel::
  Videos_pskel ()
  : video_parser_ (0),
    v_state_stack_ (sizeof (v_state_), &v_state_first_)
  {
  }

  // Directory_pskel
  //

  void Directory_pskel::
  child_parser (::restapi::Child_pskel& p)
  {
    this->child_parser_ = &p;
  }

  void Directory_pskel::
  id_parser (::xml_schema::string_pskel& p)
  {
    this->id_parser_ = &p;
  }

  void Directory_pskel::
  parent_parser (::xml_schema::string_pskel& p)
  {
    this->parent_parser_ = &p;
  }

  void Directory_pskel::
  name_parser (::xml_schema::string_pskel& p)
  {
    this->name_parser_ = &p;
  }

  void Directory_pskel::
  starred_parser (::xml_schema::date_time_pskel& p)
  {
    this->starred_parser_ = &p;
  }

  void Directory_pskel::
  parsers (::restapi::Child_pskel& child,
           ::xml_schema::string_pskel& id,
           ::xml_schema::string_pskel& parent,
           ::xml_schema::string_pskel& name,
           ::xml_schema::date_time_pskel& starred)
  {
    this->child_parser_ = &child;
    this->id_parser_ = &id;
    this->parent_parser_ = &parent;
    this->name_parser_ = &name;
    this->starred_parser_ = &starred;
  }

  Directory_pskel::
  Directory_pskel ()
  : child_parser_ (0),
    id_parser_ (0),
    parent_parser_ (0),
    name_parser_ (0),
    starred_parser_ (0),
    v_state_stack_ (sizeof (v_state_), &v_state_first_),
    v_state_attr_stack_ (sizeof (v_state_attr_), &v_state_attr_first_)
  {
  }

  // Child_pskel
  //

  void Child_pskel::
  id_parser (::xml_schema::string_pskel& p)
  {
    this->id_parser_ = &p;
  }

  void Child_pskel::
  parent_parser (::xml_schema::string_pskel& p)
  {
    this->parent_parser_ = &p;
  }

  void Child_pskel::
  isDir_parser (::xml_schema::boolean_pskel& p)
  {
    this->isDir_parser_ = &p;
  }

  void Child_pskel::
  title_parser (::xml_schema::string_pskel& p)
  {
    this->title_parser_ = &p;
  }

  void Child_pskel::
  album_parser (::xml_schema::string_pskel& p)
  {
    this->album_parser_ = &p;
  }

  void Child_pskel::
  artist_parser (::xml_schema::string_pskel& p)
  {
    this->artist_parser_ = &p;
  }

  void Child_pskel::
  track_parser (::xml_schema::int_pskel& p)
  {
    this->track_parser_ = &p;
  }

  void Child_pskel::
  year_parser (::xml_schema::int_pskel& p)
  {
    this->year_parser_ = &p;
  }

  void Child_pskel::
  genre_parser (::xml_schema::string_pskel& p)
  {
    this->genre_parser_ = &p;
  }

  void Child_pskel::
  coverArt_parser (::xml_schema::string_pskel& p)
  {
    this->coverArt_parser_ = &p;
  }

  void Child_pskel::
  size_parser (::xml_schema::long_pskel& p)
  {
    this->size_parser_ = &p;
  }

  void Child_pskel::
  contentType_parser (::xml_schema::string_pskel& p)
  {
    this->contentType_parser_ = &p;
  }

  void Child_pskel::
  suffix_parser (::xml_schema::string_pskel& p)
  {
    this->suffix_parser_ = &p;
  }

  void Child_pskel::
  transcodedContentType_parser (::xml_schema::string_pskel& p)
  {
    this->transcodedContentType_parser_ = &p;
  }

  void Child_pskel::
  transcodedSuffix_parser (::xml_schema::string_pskel& p)
  {
    this->transcodedSuffix_parser_ = &p;
  }

  void Child_pskel::
  duration_parser (::xml_schema::int_pskel& p)
  {
    this->duration_parser_ = &p;
  }

  void Child_pskel::
  bitRate_parser (::xml_schema::int_pskel& p)
  {
    this->bitRate_parser_ = &p;
  }

  void Child_pskel::
  path_parser (::xml_schema::string_pskel& p)
  {
    this->path_parser_ = &p;
  }

  void Child_pskel::
  isVideo_parser (::xml_schema::boolean_pskel& p)
  {
    this->isVideo_parser_ = &p;
  }

  void Child_pskel::
  userRating_parser (::restapi::UserRating_pskel& p)
  {
    this->userRating_parser_ = &p;
  }

  void Child_pskel::
  averageRating_parser (::restapi::AverageRating_pskel& p)
  {
    this->averageRating_parser_ = &p;
  }

  void Child_pskel::
  discNumber_parser (::xml_schema::int_pskel& p)
  {
    this->discNumber_parser_ = &p;
  }

  void Child_pskel::
  created_parser (::xml_schema::date_time_pskel& p)
  {
    this->created_parser_ = &p;
  }

  void Child_pskel::
  starred_parser (::xml_schema::date_time_pskel& p)
  {
    this->starred_parser_ = &p;
  }

  void Child_pskel::
  albumId_parser (::xml_schema::string_pskel& p)
  {
    this->albumId_parser_ = &p;
  }

  void Child_pskel::
  artistId_parser (::xml_schema::string_pskel& p)
  {
    this->artistId_parser_ = &p;
  }

  void Child_pskel::
  type_parser (::restapi::MediaType_pskel& p)
  {
    this->type_parser_ = &p;
  }

  void Child_pskel::
  bookmarkPosition_parser (::xml_schema::long_pskel& p)
  {
    this->bookmarkPosition_parser_ = &p;
  }

  void Child_pskel::
  parsers (::xml_schema::string_pskel& id,
           ::xml_schema::string_pskel& parent,
           ::xml_schema::boolean_pskel& isDir,
           ::xml_schema::string_pskel& title,
           ::xml_schema::string_pskel& album,
           ::xml_schema::string_pskel& artist,
           ::xml_schema::int_pskel& track,
           ::xml_schema::int_pskel& year,
           ::xml_schema::string_pskel& genre,
           ::xml_schema::string_pskel& coverArt,
           ::xml_schema::long_pskel& size,
           ::xml_schema::string_pskel& contentType,
           ::xml_schema::string_pskel& suffix,
           ::xml_schema::string_pskel& transcodedContentType,
           ::xml_schema::string_pskel& transcodedSuffix,
           ::xml_schema::int_pskel& duration,
           ::xml_schema::int_pskel& bitRate,
           ::xml_schema::string_pskel& path,
           ::xml_schema::boolean_pskel& isVideo,
           ::restapi::UserRating_pskel& userRating,
           ::restapi::AverageRating_pskel& averageRating,
           ::xml_schema::int_pskel& discNumber,
           ::xml_schema::date_time_pskel& created,
           ::xml_schema::date_time_pskel& starred,
           ::xml_schema::string_pskel& albumId,
           ::xml_schema::string_pskel& artistId,
           ::restapi::MediaType_pskel& type,
           ::xml_schema::long_pskel& bookmarkPosition)
  {
    this->id_parser_ = &id;
    this->parent_parser_ = &parent;
    this->isDir_parser_ = &isDir;
    this->title_parser_ = &title;
    this->album_parser_ = &album;
    this->artist_parser_ = &artist;
    this->track_parser_ = &track;
    this->year_parser_ = &year;
    this->genre_parser_ = &genre;
    this->coverArt_parser_ = &coverArt;
    this->size_parser_ = &size;
    this->contentType_parser_ = &contentType;
    this->suffix_parser_ = &suffix;
    this->transcodedContentType_parser_ = &transcodedContentType;
    this->transcodedSuffix_parser_ = &transcodedSuffix;
    this->duration_parser_ = &duration;
    this->bitRate_parser_ = &bitRate;
    this->path_parser_ = &path;
    this->isVideo_parser_ = &isVideo;
    this->userRating_parser_ = &userRating;
    this->averageRating_parser_ = &averageRating;
    this->discNumber_parser_ = &discNumber;
    this->created_parser_ = &created;
    this->starred_parser_ = &starred;
    this->albumId_parser_ = &albumId;
    this->artistId_parser_ = &artistId;
    this->type_parser_ = &type;
    this->bookmarkPosition_parser_ = &bookmarkPosition;
  }

  Child_pskel::
  Child_pskel ()
  : id_parser_ (0),
    parent_parser_ (0),
    isDir_parser_ (0),
    title_parser_ (0),
    album_parser_ (0),
    artist_parser_ (0),
    track_parser_ (0),
    year_parser_ (0),
    genre_parser_ (0),
    coverArt_parser_ (0),
    size_parser_ (0),
    contentType_parser_ (0),
    suffix_parser_ (0),
    transcodedContentType_parser_ (0),
    transcodedSuffix_parser_ (0),
    duration_parser_ (0),
    bitRate_parser_ (0),
    path_parser_ (0),
    isVideo_parser_ (0),
    userRating_parser_ (0),
    averageRating_parser_ (0),
    discNumber_parser_ (0),
    created_parser_ (0),
    starred_parser_ (0),
    albumId_parser_ (0),
    artistId_parser_ (0),
    type_parser_ (0),
    bookmarkPosition_parser_ (0),
    v_state_attr_stack_ (sizeof (v_state_attr_), &v_state_attr_first_)
  {
  }

  // NowPlaying_pskel
  //

  void NowPlaying_pskel::
  entry_parser (::restapi::NowPlayingEntry_pskel& p)
  {
    this->entry_parser_ = &p;
  }

  void NowPlaying_pskel::
  parsers (::restapi::NowPlayingEntry_pskel& entry)
  {
    this->entry_parser_ = &entry;
  }

  NowPlaying_pskel::
  NowPlaying_pskel ()
  : entry_parser_ (0),
    v_state_stack_ (sizeof (v_state_), &v_state_first_)
  {
  }

  // NowPlayingEntry_pskel
  //

  void NowPlayingEntry_pskel::
  username_parser (::xml_schema::string_pskel& p)
  {
    this->username_parser_ = &p;
  }

  void NowPlayingEntry_pskel::
  minutesAgo_parser (::xml_schema::int_pskel& p)
  {
    this->minutesAgo_parser_ = &p;
  }

  void NowPlayingEntry_pskel::
  playerId_parser (::xml_schema::int_pskel& p)
  {
    this->playerId_parser_ = &p;
  }

  void NowPlayingEntry_pskel::
  playerName_parser (::xml_schema::string_pskel& p)
  {
    this->playerName_parser_ = &p;
  }

  void NowPlayingEntry_pskel::
  parsers (::xml_schema::string_pskel& id,
           ::xml_schema::string_pskel& parent,
           ::xml_schema::boolean_pskel& isDir,
           ::xml_schema::string_pskel& title,
           ::xml_schema::string_pskel& album,
           ::xml_schema::string_pskel& artist,
           ::xml_schema::int_pskel& track,
           ::xml_schema::int_pskel& year,
           ::xml_schema::string_pskel& genre,
           ::xml_schema::string_pskel& coverArt,
           ::xml_schema::long_pskel& size,
           ::xml_schema::string_pskel& contentType,
           ::xml_schema::string_pskel& suffix,
           ::xml_schema::string_pskel& transcodedContentType,
           ::xml_schema::string_pskel& transcodedSuffix,
           ::xml_schema::int_pskel& duration,
           ::xml_schema::int_pskel& bitRate,
           ::xml_schema::string_pskel& path,
           ::xml_schema::boolean_pskel& isVideo,
           ::restapi::UserRating_pskel& userRating,
           ::restapi::AverageRating_pskel& averageRating,
           ::xml_schema::int_pskel& discNumber,
           ::xml_schema::date_time_pskel& created,
           ::xml_schema::date_time_pskel& starred,
           ::xml_schema::string_pskel& albumId,
           ::xml_schema::string_pskel& artistId,
           ::restapi::MediaType_pskel& type,
           ::xml_schema::long_pskel& bookmarkPosition,
           ::xml_schema::string_pskel& username,
           ::xml_schema::int_pskel& minutesAgo,
           ::xml_schema::int_pskel& playerId,
           ::xml_schema::string_pskel& playerName)
  {
    this->id_parser_ = &id;
    this->parent_parser_ = &parent;
    this->isDir_parser_ = &isDir;
    this->title_parser_ = &title;
    this->album_parser_ = &album;
    this->artist_parser_ = &artist;
    this->track_parser_ = &track;
    this->year_parser_ = &year;
    this->genre_parser_ = &genre;
    this->coverArt_parser_ = &coverArt;
    this->size_parser_ = &size;
    this->contentType_parser_ = &contentType;
    this->suffix_parser_ = &suffix;
    this->transcodedContentType_parser_ = &transcodedContentType;
    this->transcodedSuffix_parser_ = &transcodedSuffix;
    this->duration_parser_ = &duration;
    this->bitRate_parser_ = &bitRate;
    this->path_parser_ = &path;
    this->isVideo_parser_ = &isVideo;
    this->userRating_parser_ = &userRating;
    this->averageRating_parser_ = &averageRating;
    this->discNumber_parser_ = &discNumber;
    this->created_parser_ = &created;
    this->starred_parser_ = &starred;
    this->albumId_parser_ = &albumId;
    this->artistId_parser_ = &artistId;
    this->type_parser_ = &type;
    this->bookmarkPosition_parser_ = &bookmarkPosition;
    this->username_parser_ = &username;
    this->minutesAgo_parser_ = &minutesAgo;
    this->playerId_parser_ = &playerId;
    this->playerName_parser_ = &playerName;
  }

  NowPlayingEntry_pskel::
  NowPlayingEntry_pskel ()
  : username_parser_ (0),
    minutesAgo_parser_ (0),
    playerId_parser_ (0),
    playerName_parser_ (0),
    v_state_attr_stack_ (sizeof (v_state_attr_), &v_state_attr_first_)
  {
  }

  // SearchResult_pskel
  //

  void SearchResult_pskel::
  match_parser (::restapi::Child_pskel& p)
  {
    this->match_parser_ = &p;
  }

  void SearchResult_pskel::
  offset_parser (::xml_schema::int_pskel& p)
  {
    this->offset_parser_ = &p;
  }

  void SearchResult_pskel::
  totalHits_parser (::xml_schema::int_pskel& p)
  {
    this->totalHits_parser_ = &p;
  }

  void SearchResult_pskel::
  parsers (::restapi::Child_pskel& match,
           ::xml_schema::int_pskel& offset,
           ::xml_schema::int_pskel& totalHits)
  {
    this->match_parser_ = &match;
    this->offset_parser_ = &offset;
    this->totalHits_parser_ = &totalHits;
  }

  SearchResult_pskel::
  SearchResult_pskel ()
  : match_parser_ (0),
    offset_parser_ (0),
    totalHits_parser_ (0),
    v_state_stack_ (sizeof (v_state_), &v_state_first_),
    v_state_attr_stack_ (sizeof (v_state_attr_), &v_state_attr_first_)
  {
  }

  // SearchResult2_pskel
  //

  void SearchResult2_pskel::
  artist_parser (::restapi::Artist_pskel& p)
  {
    this->artist_parser_ = &p;
  }

  void SearchResult2_pskel::
  album_parser (::restapi::Child_pskel& p)
  {
    this->album_parser_ = &p;
  }

  void SearchResult2_pskel::
  song_parser (::restapi::Child_pskel& p)
  {
    this->song_parser_ = &p;
  }

  void SearchResult2_pskel::
  parsers (::restapi::Artist_pskel& artist,
           ::restapi::Child_pskel& album,
           ::restapi::Child_pskel& song)
  {
    this->artist_parser_ = &artist;
    this->album_parser_ = &album;
    this->song_parser_ = &song;
  }

  SearchResult2_pskel::
  SearchResult2_pskel ()
  : artist_parser_ (0),
    album_parser_ (0),
    song_parser_ (0),
    v_state_stack_ (sizeof (v_state_), &v_state_first_)
  {
  }

  // SearchResult3_pskel
  //

  void SearchResult3_pskel::
  artist_parser (::restapi::ArtistID3_pskel& p)
  {
    this->artist_parser_ = &p;
  }

  void SearchResult3_pskel::
  album_parser (::restapi::AlbumID3_pskel& p)
  {
    this->album_parser_ = &p;
  }

  void SearchResult3_pskel::
  song_parser (::restapi::Child_pskel& p)
  {
    this->song_parser_ = &p;
  }

  void SearchResult3_pskel::
  parsers (::restapi::ArtistID3_pskel& artist,
           ::restapi::AlbumID3_pskel& album,
           ::restapi::Child_pskel& song)
  {
    this->artist_parser_ = &artist;
    this->album_parser_ = &album;
    this->song_parser_ = &song;
  }

  SearchResult3_pskel::
  SearchResult3_pskel ()
  : artist_parser_ (0),
    album_parser_ (0),
    song_parser_ (0),
    v_state_stack_ (sizeof (v_state_), &v_state_first_)
  {
  }

  // Playlists_pskel
  //

  void Playlists_pskel::
  playlist_parser (::restapi::Playlist_pskel& p)
  {
    this->playlist_parser_ = &p;
  }

  void Playlists_pskel::
  parsers (::restapi::Playlist_pskel& playlist)
  {
    this->playlist_parser_ = &playlist;
  }

  Playlists_pskel::
  Playlists_pskel ()
  : playlist_parser_ (0),
    v_state_stack_ (sizeof (v_state_), &v_state_first_)
  {
  }

  // Playlist_pskel
  //

  void Playlist_pskel::
  allowedUser_parser (::xml_schema::string_pskel& p)
  {
    this->allowedUser_parser_ = &p;
  }

  void Playlist_pskel::
  id_parser (::xml_schema::string_pskel& p)
  {
    this->id_parser_ = &p;
  }

  void Playlist_pskel::
  name_parser (::xml_schema::string_pskel& p)
  {
    this->name_parser_ = &p;
  }

  void Playlist_pskel::
  comment_parser (::xml_schema::string_pskel& p)
  {
    this->comment_parser_ = &p;
  }

  void Playlist_pskel::
  owner_parser (::xml_schema::string_pskel& p)
  {
    this->owner_parser_ = &p;
  }

  void Playlist_pskel::
  public_parser (::xml_schema::boolean_pskel& p)
  {
    this->public__parser_ = &p;
  }

  void Playlist_pskel::
  songCount_parser (::xml_schema::int_pskel& p)
  {
    this->songCount_parser_ = &p;
  }

  void Playlist_pskel::
  duration_parser (::xml_schema::int_pskel& p)
  {
    this->duration_parser_ = &p;
  }

  void Playlist_pskel::
  created_parser (::xml_schema::date_time_pskel& p)
  {
    this->created_parser_ = &p;
  }

  void Playlist_pskel::
  parsers (::xml_schema::string_pskel& allowedUser,
           ::xml_schema::string_pskel& id,
           ::xml_schema::string_pskel& name,
           ::xml_schema::string_pskel& comment,
           ::xml_schema::string_pskel& owner,
           ::xml_schema::boolean_pskel& public_,
           ::xml_schema::int_pskel& songCount,
           ::xml_schema::int_pskel& duration,
           ::xml_schema::date_time_pskel& created)
  {
    this->allowedUser_parser_ = &allowedUser;
    this->id_parser_ = &id;
    this->name_parser_ = &name;
    this->comment_parser_ = &comment;
    this->owner_parser_ = &owner;
    this->public__parser_ = &public_;
    this->songCount_parser_ = &songCount;
    this->duration_parser_ = &duration;
    this->created_parser_ = &created;
  }

  Playlist_pskel::
  Playlist_pskel ()
  : allowedUser_parser_ (0),
    id_parser_ (0),
    name_parser_ (0),
    comment_parser_ (0),
    owner_parser_ (0),
    public__parser_ (0),
    songCount_parser_ (0),
    duration_parser_ (0),
    created_parser_ (0),
    v_state_stack_ (sizeof (v_state_), &v_state_first_),
    v_state_attr_stack_ (sizeof (v_state_attr_), &v_state_attr_first_)
  {
  }

  // PlaylistWithSongs_pskel
  //

  void PlaylistWithSongs_pskel::
  entry_parser (::restapi::Child_pskel& p)
  {
    this->entry_parser_ = &p;
  }

  void PlaylistWithSongs_pskel::
  parsers (::xml_schema::string_pskel& allowedUser,
           ::xml_schema::string_pskel& id,
           ::xml_schema::string_pskel& name,
           ::xml_schema::string_pskel& comment,
           ::xml_schema::string_pskel& owner,
           ::xml_schema::boolean_pskel& public_,
           ::xml_schema::int_pskel& songCount,
           ::xml_schema::int_pskel& duration,
           ::xml_schema::date_time_pskel& created,
           ::restapi::Child_pskel& entry)
  {
    this->allowedUser_parser_ = &allowedUser;
    this->id_parser_ = &id;
    this->name_parser_ = &name;
    this->comment_parser_ = &comment;
    this->owner_parser_ = &owner;
    this->public__parser_ = &public_;
    this->songCount_parser_ = &songCount;
    this->duration_parser_ = &duration;
    this->created_parser_ = &created;
    this->entry_parser_ = &entry;
  }

  PlaylistWithSongs_pskel::
  PlaylistWithSongs_pskel ()
  : entry_parser_ (0),
    v_state_stack_ (sizeof (v_state_), &v_state_first_)
  {
  }

  // JukeboxStatus_pskel
  //

  void JukeboxStatus_pskel::
  currentIndex_parser (::xml_schema::int_pskel& p)
  {
    this->currentIndex_parser_ = &p;
  }

  void JukeboxStatus_pskel::
  playing_parser (::xml_schema::boolean_pskel& p)
  {
    this->playing_parser_ = &p;
  }

  void JukeboxStatus_pskel::
  gain_parser (::xml_schema::float_pskel& p)
  {
    this->gain_parser_ = &p;
  }

  void JukeboxStatus_pskel::
  position_parser (::xml_schema::int_pskel& p)
  {
    this->position_parser_ = &p;
  }

  void JukeboxStatus_pskel::
  parsers (::xml_schema::int_pskel& currentIndex,
           ::xml_schema::boolean_pskel& playing,
           ::xml_schema::float_pskel& gain,
           ::xml_schema::int_pskel& position)
  {
    this->currentIndex_parser_ = &currentIndex;
    this->playing_parser_ = &playing;
    this->gain_parser_ = &gain;
    this->position_parser_ = &position;
  }

  JukeboxStatus_pskel::
  JukeboxStatus_pskel ()
  : currentIndex_parser_ (0),
    playing_parser_ (0),
    gain_parser_ (0),
    position_parser_ (0),
    v_state_attr_stack_ (sizeof (v_state_attr_), &v_state_attr_first_)
  {
  }

  // JukeboxPlaylist_pskel
  //

  void JukeboxPlaylist_pskel::
  entry_parser (::restapi::Child_pskel& p)
  {
    this->entry_parser_ = &p;
  }

  void JukeboxPlaylist_pskel::
  parsers (::xml_schema::int_pskel& currentIndex,
           ::xml_schema::boolean_pskel& playing,
           ::xml_schema::float_pskel& gain,
           ::xml_schema::int_pskel& position,
           ::restapi::Child_pskel& entry)
  {
    this->currentIndex_parser_ = &currentIndex;
    this->playing_parser_ = &playing;
    this->gain_parser_ = &gain;
    this->position_parser_ = &position;
    this->entry_parser_ = &entry;
  }

  JukeboxPlaylist_pskel::
  JukeboxPlaylist_pskel ()
  : entry_parser_ (0),
    v_state_stack_ (sizeof (v_state_), &v_state_first_)
  {
  }

  // ChatMessages_pskel
  //

  void ChatMessages_pskel::
  chatMessage_parser (::restapi::ChatMessage_pskel& p)
  {
    this->chatMessage_parser_ = &p;
  }

  void ChatMessages_pskel::
  parsers (::restapi::ChatMessage_pskel& chatMessage)
  {
    this->chatMessage_parser_ = &chatMessage;
  }

  ChatMessages_pskel::
  ChatMessages_pskel ()
  : chatMessage_parser_ (0),
    v_state_stack_ (sizeof (v_state_), &v_state_first_)
  {
  }

  // ChatMessage_pskel
  //

  void ChatMessage_pskel::
  username_parser (::xml_schema::string_pskel& p)
  {
    this->username_parser_ = &p;
  }

  void ChatMessage_pskel::
  time_parser (::xml_schema::long_pskel& p)
  {
    this->time_parser_ = &p;
  }

  void ChatMessage_pskel::
  message_parser (::xml_schema::string_pskel& p)
  {
    this->message_parser_ = &p;
  }

  void ChatMessage_pskel::
  parsers (::xml_schema::string_pskel& username,
           ::xml_schema::long_pskel& time,
           ::xml_schema::string_pskel& message)
  {
    this->username_parser_ = &username;
    this->time_parser_ = &time;
    this->message_parser_ = &message;
  }

  ChatMessage_pskel::
  ChatMessage_pskel ()
  : username_parser_ (0),
    time_parser_ (0),
    message_parser_ (0),
    v_state_attr_stack_ (sizeof (v_state_attr_), &v_state_attr_first_)
  {
  }

  // AlbumList_pskel
  //

  void AlbumList_pskel::
  album_parser (::restapi::Child_pskel& p)
  {
    this->album_parser_ = &p;
  }

  void AlbumList_pskel::
  parsers (::restapi::Child_pskel& album)
  {
    this->album_parser_ = &album;
  }

  AlbumList_pskel::
  AlbumList_pskel ()
  : album_parser_ (0),
    v_state_stack_ (sizeof (v_state_), &v_state_first_)
  {
  }

  // AlbumList2_pskel
  //

  void AlbumList2_pskel::
  album_parser (::restapi::AlbumID3_pskel& p)
  {
    this->album_parser_ = &p;
  }

  void AlbumList2_pskel::
  parsers (::restapi::AlbumID3_pskel& album)
  {
    this->album_parser_ = &album;
  }

  AlbumList2_pskel::
  AlbumList2_pskel ()
  : album_parser_ (0),
    v_state_stack_ (sizeof (v_state_), &v_state_first_)
  {
  }

  // Songs_pskel
  //

  void Songs_pskel::
  song_parser (::restapi::Child_pskel& p)
  {
    this->song_parser_ = &p;
  }

  void Songs_pskel::
  parsers (::restapi::Child_pskel& song)
  {
    this->song_parser_ = &song;
  }

  Songs_pskel::
  Songs_pskel ()
  : song_parser_ (0),
    v_state_stack_ (sizeof (v_state_), &v_state_first_)
  {
  }

  // Lyrics_pskel
  //

  void Lyrics_pskel::
  artist_parser (::xml_schema::string_pskel& p)
  {
    this->artist_parser_ = &p;
  }

  void Lyrics_pskel::
  title_parser (::xml_schema::string_pskel& p)
  {
    this->title_parser_ = &p;
  }

  void Lyrics_pskel::
  parsers (::xml_schema::string_pskel& artist,
           ::xml_schema::string_pskel& title)
  {
    this->artist_parser_ = &artist;
    this->title_parser_ = &title;
  }

  Lyrics_pskel::
  Lyrics_pskel ()
  : artist_parser_ (0),
    title_parser_ (0)
  {
  }

  // Podcasts_pskel
  //

  void Podcasts_pskel::
  channel_parser (::restapi::PodcastChannel_pskel& p)
  {
    this->channel_parser_ = &p;
  }

  void Podcasts_pskel::
  parsers (::restapi::PodcastChannel_pskel& channel)
  {
    this->channel_parser_ = &channel;
  }

  Podcasts_pskel::
  Podcasts_pskel ()
  : channel_parser_ (0),
    v_state_stack_ (sizeof (v_state_), &v_state_first_)
  {
  }

  // PodcastChannel_pskel
  //

  void PodcastChannel_pskel::
  episode_parser (::restapi::PodcastEpisode_pskel& p)
  {
    this->episode_parser_ = &p;
  }

  void PodcastChannel_pskel::
  id_parser (::xml_schema::string_pskel& p)
  {
    this->id_parser_ = &p;
  }

  void PodcastChannel_pskel::
  url_parser (::xml_schema::string_pskel& p)
  {
    this->url_parser_ = &p;
  }

  void PodcastChannel_pskel::
  title_parser (::xml_schema::string_pskel& p)
  {
    this->title_parser_ = &p;
  }

  void PodcastChannel_pskel::
  description_parser (::xml_schema::string_pskel& p)
  {
    this->description_parser_ = &p;
  }

  void PodcastChannel_pskel::
  status_parser (::restapi::PodcastStatus_pskel& p)
  {
    this->status_parser_ = &p;
  }

  void PodcastChannel_pskel::
  errorMessage_parser (::xml_schema::string_pskel& p)
  {
    this->errorMessage_parser_ = &p;
  }

  void PodcastChannel_pskel::
  parsers (::restapi::PodcastEpisode_pskel& episode,
           ::xml_schema::string_pskel& id,
           ::xml_schema::string_pskel& url,
           ::xml_schema::string_pskel& title,
           ::xml_schema::string_pskel& description,
           ::restapi::PodcastStatus_pskel& status,
           ::xml_schema::string_pskel& errorMessage)
  {
    this->episode_parser_ = &episode;
    this->id_parser_ = &id;
    this->url_parser_ = &url;
    this->title_parser_ = &title;
    this->description_parser_ = &description;
    this->status_parser_ = &status;
    this->errorMessage_parser_ = &errorMessage;
  }

  PodcastChannel_pskel::
  PodcastChannel_pskel ()
  : episode_parser_ (0),
    id_parser_ (0),
    url_parser_ (0),
    title_parser_ (0),
    description_parser_ (0),
    status_parser_ (0),
    errorMessage_parser_ (0),
    v_state_stack_ (sizeof (v_state_), &v_state_first_),
    v_state_attr_stack_ (sizeof (v_state_attr_), &v_state_attr_first_)
  {
  }

  // PodcastEpisode_pskel
  //

  void PodcastEpisode_pskel::
  streamId_parser (::xml_schema::string_pskel& p)
  {
    this->streamId_parser_ = &p;
  }

  void PodcastEpisode_pskel::
  description_parser (::xml_schema::string_pskel& p)
  {
    this->description_parser_ = &p;
  }

  void PodcastEpisode_pskel::
  status_parser (::restapi::PodcastStatus_pskel& p)
  {
    this->status_parser_ = &p;
  }

  void PodcastEpisode_pskel::
  publishDate_parser (::xml_schema::date_time_pskel& p)
  {
    this->publishDate_parser_ = &p;
  }

  void PodcastEpisode_pskel::
  parsers (::xml_schema::string_pskel& id,
           ::xml_schema::string_pskel& parent,
           ::xml_schema::boolean_pskel& isDir,
           ::xml_schema::string_pskel& title,
           ::xml_schema::string_pskel& album,
           ::xml_schema::string_pskel& artist,
           ::xml_schema::int_pskel& track,
           ::xml_schema::int_pskel& year,
           ::xml_schema::string_pskel& genre,
           ::xml_schema::string_pskel& coverArt,
           ::xml_schema::long_pskel& size,
           ::xml_schema::string_pskel& contentType,
           ::xml_schema::string_pskel& suffix,
           ::xml_schema::string_pskel& transcodedContentType,
           ::xml_schema::string_pskel& transcodedSuffix,
           ::xml_schema::int_pskel& duration,
           ::xml_schema::int_pskel& bitRate,
           ::xml_schema::string_pskel& path,
           ::xml_schema::boolean_pskel& isVideo,
           ::restapi::UserRating_pskel& userRating,
           ::restapi::AverageRating_pskel& averageRating,
           ::xml_schema::int_pskel& discNumber,
           ::xml_schema::date_time_pskel& created,
           ::xml_schema::date_time_pskel& starred,
           ::xml_schema::string_pskel& albumId,
           ::xml_schema::string_pskel& artistId,
           ::restapi::MediaType_pskel& type,
           ::xml_schema::long_pskel& bookmarkPosition,
           ::xml_schema::string_pskel& streamId,
           ::xml_schema::string_pskel& description,
           ::restapi::PodcastStatus_pskel& status,
           ::xml_schema::date_time_pskel& publishDate)
  {
    this->id_parser_ = &id;
    this->parent_parser_ = &parent;
    this->isDir_parser_ = &isDir;
    this->title_parser_ = &title;
    this->album_parser_ = &album;
    this->artist_parser_ = &artist;
    this->track_parser_ = &track;
    this->year_parser_ = &year;
    this->genre_parser_ = &genre;
    this->coverArt_parser_ = &coverArt;
    this->size_parser_ = &size;
    this->contentType_parser_ = &contentType;
    this->suffix_parser_ = &suffix;
    this->transcodedContentType_parser_ = &transcodedContentType;
    this->transcodedSuffix_parser_ = &transcodedSuffix;
    this->duration_parser_ = &duration;
    this->bitRate_parser_ = &bitRate;
    this->path_parser_ = &path;
    this->isVideo_parser_ = &isVideo;
    this->userRating_parser_ = &userRating;
    this->averageRating_parser_ = &averageRating;
    this->discNumber_parser_ = &discNumber;
    this->created_parser_ = &created;
    this->starred_parser_ = &starred;
    this->albumId_parser_ = &albumId;
    this->artistId_parser_ = &artistId;
    this->type_parser_ = &type;
    this->bookmarkPosition_parser_ = &bookmarkPosition;
    this->streamId_parser_ = &streamId;
    this->description_parser_ = &description;
    this->status_parser_ = &status;
    this->publishDate_parser_ = &publishDate;
  }

  PodcastEpisode_pskel::
  PodcastEpisode_pskel ()
  : streamId_parser_ (0),
    description_parser_ (0),
    status_parser_ (0),
    publishDate_parser_ (0),
    v_state_attr_stack_ (sizeof (v_state_attr_), &v_state_attr_first_)
  {
  }

  // InternetRadioStations_pskel
  //

  void InternetRadioStations_pskel::
  internetRadioStation_parser (::restapi::InternetRadioStation_pskel& p)
  {
    this->internetRadioStation_parser_ = &p;
  }

  void InternetRadioStations_pskel::
  parsers (::restapi::InternetRadioStation_pskel& internetRadioStation)
  {
    this->internetRadioStation_parser_ = &internetRadioStation;
  }

  InternetRadioStations_pskel::
  InternetRadioStations_pskel ()
  : internetRadioStation_parser_ (0),
    v_state_stack_ (sizeof (v_state_), &v_state_first_)
  {
  }

  // InternetRadioStation_pskel
  //

  void InternetRadioStation_pskel::
  id_parser (::xml_schema::string_pskel& p)
  {
    this->id_parser_ = &p;
  }

  void InternetRadioStation_pskel::
  name_parser (::xml_schema::string_pskel& p)
  {
    this->name_parser_ = &p;
  }

  void InternetRadioStation_pskel::
  streamUrl_parser (::xml_schema::string_pskel& p)
  {
    this->streamUrl_parser_ = &p;
  }

  void InternetRadioStation_pskel::
  homePageUrl_parser (::xml_schema::string_pskel& p)
  {
    this->homePageUrl_parser_ = &p;
  }

  void InternetRadioStation_pskel::
  parsers (::xml_schema::string_pskel& id,
           ::xml_schema::string_pskel& name,
           ::xml_schema::string_pskel& streamUrl,
           ::xml_schema::string_pskel& homePageUrl)
  {
    this->id_parser_ = &id;
    this->name_parser_ = &name;
    this->streamUrl_parser_ = &streamUrl;
    this->homePageUrl_parser_ = &homePageUrl;
  }

  InternetRadioStation_pskel::
  InternetRadioStation_pskel ()
  : id_parser_ (0),
    name_parser_ (0),
    streamUrl_parser_ (0),
    homePageUrl_parser_ (0),
    v_state_attr_stack_ (sizeof (v_state_attr_), &v_state_attr_first_)
  {
  }

  // Bookmarks_pskel
  //

  void Bookmarks_pskel::
  bookmark_parser (::restapi::Bookmark_pskel& p)
  {
    this->bookmark_parser_ = &p;
  }

  void Bookmarks_pskel::
  parsers (::restapi::Bookmark_pskel& bookmark)
  {
    this->bookmark_parser_ = &bookmark;
  }

  Bookmarks_pskel::
  Bookmarks_pskel ()
  : bookmark_parser_ (0),
    v_state_stack_ (sizeof (v_state_), &v_state_first_)
  {
  }

  // Bookmark_pskel
  //

  void Bookmark_pskel::
  entry_parser (::restapi::Child_pskel& p)
  {
    this->entry_parser_ = &p;
  }

  void Bookmark_pskel::
  position_parser (::xml_schema::long_pskel& p)
  {
    this->position_parser_ = &p;
  }

  void Bookmark_pskel::
  username_parser (::xml_schema::string_pskel& p)
  {
    this->username_parser_ = &p;
  }

  void Bookmark_pskel::
  comment_parser (::xml_schema::string_pskel& p)
  {
    this->comment_parser_ = &p;
  }

  void Bookmark_pskel::
  created_parser (::xml_schema::date_time_pskel& p)
  {
    this->created_parser_ = &p;
  }

  void Bookmark_pskel::
  changed_parser (::xml_schema::date_time_pskel& p)
  {
    this->changed_parser_ = &p;
  }

  void Bookmark_pskel::
  parsers (::restapi::Child_pskel& entry,
           ::xml_schema::long_pskel& position,
           ::xml_schema::string_pskel& username,
           ::xml_schema::string_pskel& comment,
           ::xml_schema::date_time_pskel& created,
           ::xml_schema::date_time_pskel& changed)
  {
    this->entry_parser_ = &entry;
    this->position_parser_ = &position;
    this->username_parser_ = &username;
    this->comment_parser_ = &comment;
    this->created_parser_ = &created;
    this->changed_parser_ = &changed;
  }

  Bookmark_pskel::
  Bookmark_pskel ()
  : entry_parser_ (0),
    position_parser_ (0),
    username_parser_ (0),
    comment_parser_ (0),
    created_parser_ (0),
    changed_parser_ (0),
    v_state_stack_ (sizeof (v_state_), &v_state_first_),
    v_state_attr_stack_ (sizeof (v_state_attr_), &v_state_attr_first_)
  {
  }

  // Shares_pskel
  //

  void Shares_pskel::
  share_parser (::restapi::Share_pskel& p)
  {
    this->share_parser_ = &p;
  }

  void Shares_pskel::
  parsers (::restapi::Share_pskel& share)
  {
    this->share_parser_ = &share;
  }

  Shares_pskel::
  Shares_pskel ()
  : share_parser_ (0),
    v_state_stack_ (sizeof (v_state_), &v_state_first_)
  {
  }

  // Share_pskel
  //

  void Share_pskel::
  entry_parser (::restapi::Child_pskel& p)
  {
    this->entry_parser_ = &p;
  }

  void Share_pskel::
  id_parser (::xml_schema::string_pskel& p)
  {
    this->id_parser_ = &p;
  }

  void Share_pskel::
  url_parser (::xml_schema::string_pskel& p)
  {
    this->url_parser_ = &p;
  }

  void Share_pskel::
  description_parser (::xml_schema::string_pskel& p)
  {
    this->description_parser_ = &p;
  }

  void Share_pskel::
  username_parser (::xml_schema::string_pskel& p)
  {
    this->username_parser_ = &p;
  }

  void Share_pskel::
  created_parser (::xml_schema::date_time_pskel& p)
  {
    this->created_parser_ = &p;
  }

  void Share_pskel::
  expires_parser (::xml_schema::date_time_pskel& p)
  {
    this->expires_parser_ = &p;
  }

  void Share_pskel::
  lastVisited_parser (::xml_schema::date_time_pskel& p)
  {
    this->lastVisited_parser_ = &p;
  }

  void Share_pskel::
  visitCount_parser (::xml_schema::int_pskel& p)
  {
    this->visitCount_parser_ = &p;
  }

  void Share_pskel::
  parsers (::restapi::Child_pskel& entry,
           ::xml_schema::string_pskel& id,
           ::xml_schema::string_pskel& url,
           ::xml_schema::string_pskel& description,
           ::xml_schema::string_pskel& username,
           ::xml_schema::date_time_pskel& created,
           ::xml_schema::date_time_pskel& expires,
           ::xml_schema::date_time_pskel& lastVisited,
           ::xml_schema::int_pskel& visitCount)
  {
    this->entry_parser_ = &entry;
    this->id_parser_ = &id;
    this->url_parser_ = &url;
    this->description_parser_ = &description;
    this->username_parser_ = &username;
    this->created_parser_ = &created;
    this->expires_parser_ = &expires;
    this->lastVisited_parser_ = &lastVisited;
    this->visitCount_parser_ = &visitCount;
  }

  Share_pskel::
  Share_pskel ()
  : entry_parser_ (0),
    id_parser_ (0),
    url_parser_ (0),
    description_parser_ (0),
    username_parser_ (0),
    created_parser_ (0),
    expires_parser_ (0),
    lastVisited_parser_ (0),
    visitCount_parser_ (0),
    v_state_stack_ (sizeof (v_state_), &v_state_first_),
    v_state_attr_stack_ (sizeof (v_state_attr_), &v_state_attr_first_)
  {
  }

  // Starred_pskel
  //

  void Starred_pskel::
  artist_parser (::restapi::Artist_pskel& p)
  {
    this->artist_parser_ = &p;
  }

  void Starred_pskel::
  album_parser (::restapi::Child_pskel& p)
  {
    this->album_parser_ = &p;
  }

  void Starred_pskel::
  song_parser (::restapi::Child_pskel& p)
  {
    this->song_parser_ = &p;
  }

  void Starred_pskel::
  parsers (::restapi::Artist_pskel& artist,
           ::restapi::Child_pskel& album,
           ::restapi::Child_pskel& song)
  {
    this->artist_parser_ = &artist;
    this->album_parser_ = &album;
    this->song_parser_ = &song;
  }

  Starred_pskel::
  Starred_pskel ()
  : artist_parser_ (0),
    album_parser_ (0),
    song_parser_ (0),
    v_state_stack_ (sizeof (v_state_), &v_state_first_)
  {
  }

  // Starred2_pskel
  //

  void Starred2_pskel::
  artist_parser (::restapi::ArtistID3_pskel& p)
  {
    this->artist_parser_ = &p;
  }

  void Starred2_pskel::
  album_parser (::restapi::AlbumID3_pskel& p)
  {
    this->album_parser_ = &p;
  }

  void Starred2_pskel::
  song_parser (::restapi::Child_pskel& p)
  {
    this->song_parser_ = &p;
  }

  void Starred2_pskel::
  parsers (::restapi::ArtistID3_pskel& artist,
           ::restapi::AlbumID3_pskel& album,
           ::restapi::Child_pskel& song)
  {
    this->artist_parser_ = &artist;
    this->album_parser_ = &album;
    this->song_parser_ = &song;
  }

  Starred2_pskel::
  Starred2_pskel ()
  : artist_parser_ (0),
    album_parser_ (0),
    song_parser_ (0),
    v_state_stack_ (sizeof (v_state_), &v_state_first_)
  {
  }

  // License_pskel
  //

  void License_pskel::
  valid_parser (::xml_schema::boolean_pskel& p)
  {
    this->valid_parser_ = &p;
  }

  void License_pskel::
  email_parser (::xml_schema::string_pskel& p)
  {
    this->email_parser_ = &p;
  }

  void License_pskel::
  key_parser (::xml_schema::string_pskel& p)
  {
    this->key_parser_ = &p;
  }

  void License_pskel::
  date_parser (::xml_schema::date_time_pskel& p)
  {
    this->date_parser_ = &p;
  }

  void License_pskel::
  parsers (::xml_schema::boolean_pskel& valid,
           ::xml_schema::string_pskel& email,
           ::xml_schema::string_pskel& key,
           ::xml_schema::date_time_pskel& date)
  {
    this->valid_parser_ = &valid;
    this->email_parser_ = &email;
    this->key_parser_ = &key;
    this->date_parser_ = &date;
  }

  License_pskel::
  License_pskel ()
  : valid_parser_ (0),
    email_parser_ (0),
    key_parser_ (0),
    date_parser_ (0),
    v_state_attr_stack_ (sizeof (v_state_attr_), &v_state_attr_first_)
  {
  }

  // Users_pskel
  //

  void Users_pskel::
  user_parser (::restapi::User_pskel& p)
  {
    this->user_parser_ = &p;
  }

  void Users_pskel::
  parsers (::restapi::User_pskel& user)
  {
    this->user_parser_ = &user;
  }

  Users_pskel::
  Users_pskel ()
  : user_parser_ (0),
    v_state_stack_ (sizeof (v_state_), &v_state_first_)
  {
  }

  // User_pskel
  //

  void User_pskel::
  username_parser (::xml_schema::string_pskel& p)
  {
    this->username_parser_ = &p;
  }

  void User_pskel::
  email_parser (::xml_schema::string_pskel& p)
  {
    this->email_parser_ = &p;
  }

  void User_pskel::
  scrobblingEnabled_parser (::xml_schema::boolean_pskel& p)
  {
    this->scrobblingEnabled_parser_ = &p;
  }

  void User_pskel::
  adminRole_parser (::xml_schema::boolean_pskel& p)
  {
    this->adminRole_parser_ = &p;
  }

  void User_pskel::
  settingsRole_parser (::xml_schema::boolean_pskel& p)
  {
    this->settingsRole_parser_ = &p;
  }

  void User_pskel::
  downloadRole_parser (::xml_schema::boolean_pskel& p)
  {
    this->downloadRole_parser_ = &p;
  }

  void User_pskel::
  uploadRole_parser (::xml_schema::boolean_pskel& p)
  {
    this->uploadRole_parser_ = &p;
  }

  void User_pskel::
  playlistRole_parser (::xml_schema::boolean_pskel& p)
  {
    this->playlistRole_parser_ = &p;
  }

  void User_pskel::
  coverArtRole_parser (::xml_schema::boolean_pskel& p)
  {
    this->coverArtRole_parser_ = &p;
  }

  void User_pskel::
  commentRole_parser (::xml_schema::boolean_pskel& p)
  {
    this->commentRole_parser_ = &p;
  }

  void User_pskel::
  podcastRole_parser (::xml_schema::boolean_pskel& p)
  {
    this->podcastRole_parser_ = &p;
  }

  void User_pskel::
  streamRole_parser (::xml_schema::boolean_pskel& p)
  {
    this->streamRole_parser_ = &p;
  }

  void User_pskel::
  jukeboxRole_parser (::xml_schema::boolean_pskel& p)
  {
    this->jukeboxRole_parser_ = &p;
  }

  void User_pskel::
  shareRole_parser (::xml_schema::boolean_pskel& p)
  {
    this->shareRole_parser_ = &p;
  }

  void User_pskel::
  parsers (::xml_schema::string_pskel& username,
           ::xml_schema::string_pskel& email,
           ::xml_schema::boolean_pskel& scrobblingEnabled,
           ::xml_schema::boolean_pskel& adminRole,
           ::xml_schema::boolean_pskel& settingsRole,
           ::xml_schema::boolean_pskel& downloadRole,
           ::xml_schema::boolean_pskel& uploadRole,
           ::xml_schema::boolean_pskel& playlistRole,
           ::xml_schema::boolean_pskel& coverArtRole,
           ::xml_schema::boolean_pskel& commentRole,
           ::xml_schema::boolean_pskel& podcastRole,
           ::xml_schema::boolean_pskel& streamRole,
           ::xml_schema::boolean_pskel& jukeboxRole,
           ::xml_schema::boolean_pskel& shareRole)
  {
    this->username_parser_ = &username;
    this->email_parser_ = &email;
    this->scrobblingEnabled_parser_ = &scrobblingEnabled;
    this->adminRole_parser_ = &adminRole;
    this->settingsRole_parser_ = &settingsRole;
    this->downloadRole_parser_ = &downloadRole;
    this->uploadRole_parser_ = &uploadRole;
    this->playlistRole_parser_ = &playlistRole;
    this->coverArtRole_parser_ = &coverArtRole;
    this->commentRole_parser_ = &commentRole;
    this->podcastRole_parser_ = &podcastRole;
    this->streamRole_parser_ = &streamRole;
    this->jukeboxRole_parser_ = &jukeboxRole;
    this->shareRole_parser_ = &shareRole;
  }

  User_pskel::
  User_pskel ()
  : username_parser_ (0),
    email_parser_ (0),
    scrobblingEnabled_parser_ (0),
    adminRole_parser_ (0),
    settingsRole_parser_ (0),
    downloadRole_parser_ (0),
    uploadRole_parser_ (0),
    playlistRole_parser_ (0),
    coverArtRole_parser_ (0),
    commentRole_parser_ (0),
    podcastRole_parser_ (0),
    streamRole_parser_ (0),
    jukeboxRole_parser_ (0),
    shareRole_parser_ (0),
    v_state_attr_stack_ (sizeof (v_state_attr_), &v_state_attr_first_)
  {
  }

  // Error_pskel
  //

  void Error_pskel::
  code_parser (::xml_schema::int_pskel& p)
  {
    this->code_parser_ = &p;
  }

  void Error_pskel::
  message_parser (::xml_schema::string_pskel& p)
  {
    this->message_parser_ = &p;
  }

  void Error_pskel::
  parsers (::xml_schema::int_pskel& code,
           ::xml_schema::string_pskel& message)
  {
    this->code_parser_ = &code;
    this->message_parser_ = &message;
  }

  Error_pskel::
  Error_pskel ()
  : code_parser_ (0),
    message_parser_ (0),
    v_state_attr_stack_ (sizeof (v_state_attr_), &v_state_attr_first_)
  {
  }
}

namespace restapi
{
  // Response_pskel
  //

  void Response_pskel::
  musicFolders ()
  {
  }

  void Response_pskel::
  indexes ()
  {
  }

  void Response_pskel::
  directory ()
  {
  }

  void Response_pskel::
  genres ()
  {
  }

  void Response_pskel::
  artists ()
  {
  }

  void Response_pskel::
  artist ()
  {
  }

  void Response_pskel::
  album ()
  {
  }

  void Response_pskel::
  song ()
  {
  }

  void Response_pskel::
  videos ()
  {
  }

  void Response_pskel::
  nowPlaying ()
  {
  }

  void Response_pskel::
  searchResult ()
  {
  }

  void Response_pskel::
  searchResult2 ()
  {
  }

  void Response_pskel::
  searchResult3 ()
  {
  }

  void Response_pskel::
  playlists ()
  {
  }

  void Response_pskel::
  playlist ()
  {
  }

  void Response_pskel::
  jukeboxStatus ()
  {
  }

  void Response_pskel::
  jukeboxPlaylist ()
  {
  }

  void Response_pskel::
  license ()
  {
  }

  void Response_pskel::
  users ()
  {
  }

  void Response_pskel::
  user ()
  {
  }

  void Response_pskel::
  chatMessages ()
  {
  }

  void Response_pskel::
  albumList ()
  {
  }

  void Response_pskel::
  albumList2 ()
  {
  }

  void Response_pskel::
  randomSongs ()
  {
  }

  void Response_pskel::
  songsByGenre ()
  {
  }

  void Response_pskel::
  lyrics ()
  {
  }

  void Response_pskel::
  podcasts ()
  {
  }

  void Response_pskel::
  internetRadioStations ()
  {
  }

  void Response_pskel::
  bookmarks ()
  {
  }

  void Response_pskel::
  shares ()
  {
  }

  void Response_pskel::
  starred ()
  {
  }

  void Response_pskel::
  starred2 ()
  {
  }

  void Response_pskel::
  error ()
  {
  }

  void Response_pskel::
  status ()
  {
  }

  void Response_pskel::
  version ()
  {
  }

  void Response_pskel::
  post_Response ()
  {
  }

  // ResponseStatus_pskel
  //

  void ResponseStatus_pskel::
  post_ResponseStatus ()
  {
  }

  // Version_pskel
  //

  void Version_pskel::
  post_Version ()
  {
  }

  // MusicFolders_pskel
  //

  void MusicFolders_pskel::
  musicFolder ()
  {
  }

  void MusicFolders_pskel::
  post_MusicFolders ()
  {
  }

  // MusicFolder_pskel
  //

  void MusicFolder_pskel::
  id (int)
  {
  }

  void MusicFolder_pskel::
  name (const ::std::string&)
  {
  }

  void MusicFolder_pskel::
  post_MusicFolder ()
  {
  }

  // Indexes_pskel
  //

  void Indexes_pskel::
  shortcut ()
  {
  }

  void Indexes_pskel::
  index ()
  {
  }

  void Indexes_pskel::
  child ()
  {
  }

  void Indexes_pskel::
  lastModified (long long)
  {
  }

  void Indexes_pskel::
  ignoredArticles (const ::std::string&)
  {
  }

  void Indexes_pskel::
  post_Indexes ()
  {
  }

  // Index_pskel
  //

  void Index_pskel::
  artist ()
  {
  }

  void Index_pskel::
  name (const ::std::string&)
  {
  }

  void Index_pskel::
  post_Index ()
  {
  }

  // Artist_pskel
  //

  void Artist_pskel::
  id (const ::std::string&)
  {
  }

  void Artist_pskel::
  name (const ::std::string&)
  {
  }

  void Artist_pskel::
  starred (const ::xml_schema::date_time&)
  {
  }

  void Artist_pskel::
  post_Artist ()
  {
  }

  // Genres_pskel
  //

  void Genres_pskel::
  genre ()
  {
  }

  void Genres_pskel::
  post_Genres ()
  {
  }

  // Genre_pskel
  //

  void Genre_pskel::
  songCount (int)
  {
  }

  void Genre_pskel::
  albumCount (int)
  {
  }

  void Genre_pskel::
  post_Genre ()
  {
  }

  // ArtistsID3_pskel
  //

  void ArtistsID3_pskel::
  index ()
  {
  }

  void ArtistsID3_pskel::
  ignoredArticles (const ::std::string&)
  {
  }

  void ArtistsID3_pskel::
  post_ArtistsID3 ()
  {
  }

  // IndexID3_pskel
  //

  void IndexID3_pskel::
  artist ()
  {
  }

  void IndexID3_pskel::
  name (const ::std::string&)
  {
  }

  void IndexID3_pskel::
  post_IndexID3 ()
  {
  }

  // ArtistID3_pskel
  //

  void ArtistID3_pskel::
  id (const ::std::string&)
  {
  }

  void ArtistID3_pskel::
  name (const ::std::string&)
  {
  }

  void ArtistID3_pskel::
  coverArt (const ::std::string&)
  {
  }

  void ArtistID3_pskel::
  albumCount (int)
  {
  }

  void ArtistID3_pskel::
  starred (const ::xml_schema::date_time&)
  {
  }

  void ArtistID3_pskel::
  post_ArtistID3 ()
  {
  }

  // ArtistWithAlbumsID3_pskel
  //

  void ArtistWithAlbumsID3_pskel::
  album ()
  {
  }

  void ArtistWithAlbumsID3_pskel::
  post_ArtistWithAlbumsID3 ()
  {
    post_ArtistID3 ();
  }

  // AlbumID3_pskel
  //

  void AlbumID3_pskel::
  id (const ::std::string&)
  {
  }

  void AlbumID3_pskel::
  name (const ::std::string&)
  {
  }

  void AlbumID3_pskel::
  artist (const ::std::string&)
  {
  }

  void AlbumID3_pskel::
  artistId (const ::std::string&)
  {
  }

  void AlbumID3_pskel::
  coverArt (const ::std::string&)
  {
  }

  void AlbumID3_pskel::
  songCount (int)
  {
  }

  void AlbumID3_pskel::
  duration (int)
  {
  }

  void AlbumID3_pskel::
  created (const ::xml_schema::date_time&)
  {
  }

  void AlbumID3_pskel::
  starred (const ::xml_schema::date_time&)
  {
  }

  void AlbumID3_pskel::
  year (int)
  {
  }

  void AlbumID3_pskel::
  genre (const ::std::string&)
  {
  }

  void AlbumID3_pskel::
  post_AlbumID3 ()
  {
  }

  // AlbumWithSongsID3_pskel
  //

  void AlbumWithSongsID3_pskel::
  song ()
  {
  }

  void AlbumWithSongsID3_pskel::
  post_AlbumWithSongsID3 ()
  {
    post_AlbumID3 ();
  }

  // Videos_pskel
  //

  void Videos_pskel::
  video ()
  {
  }

  void Videos_pskel::
  post_Videos ()
  {
  }

  // Directory_pskel
  //

  void Directory_pskel::
  child ()
  {
  }

  void Directory_pskel::
  id (const ::std::string&)
  {
  }

  void Directory_pskel::
  parent (const ::std::string&)
  {
  }

  void Directory_pskel::
  name (const ::std::string&)
  {
  }

  void Directory_pskel::
  starred (const ::xml_schema::date_time&)
  {
  }

  void Directory_pskel::
  post_Directory ()
  {
  }

  // Child_pskel
  //

  void Child_pskel::
  id (const ::std::string&)
  {
  }

  void Child_pskel::
  parent (const ::std::string&)
  {
  }

  void Child_pskel::
  isDir (bool)
  {
  }

  void Child_pskel::
  title (const ::std::string&)
  {
  }

  void Child_pskel::
  album (const ::std::string&)
  {
  }

  void Child_pskel::
  artist (const ::std::string&)
  {
  }

  void Child_pskel::
  track (int)
  {
  }

  void Child_pskel::
  year (int)
  {
  }

  void Child_pskel::
  genre (const ::std::string&)
  {
  }

  void Child_pskel::
  coverArt (const ::std::string&)
  {
  }

  void Child_pskel::
  size (long long)
  {
  }

  void Child_pskel::
  contentType (const ::std::string&)
  {
  }

  void Child_pskel::
  suffix (const ::std::string&)
  {
  }

  void Child_pskel::
  transcodedContentType (const ::std::string&)
  {
  }

  void Child_pskel::
  transcodedSuffix (const ::std::string&)
  {
  }

  void Child_pskel::
  duration (int)
  {
  }

  void Child_pskel::
  bitRate (int)
  {
  }

  void Child_pskel::
  path (const ::std::string&)
  {
  }

  void Child_pskel::
  isVideo (bool)
  {
  }

  void Child_pskel::
  userRating ()
  {
  }

  void Child_pskel::
  averageRating ()
  {
  }

  void Child_pskel::
  discNumber (int)
  {
  }

  void Child_pskel::
  created (const ::xml_schema::date_time&)
  {
  }

  void Child_pskel::
  starred (const ::xml_schema::date_time&)
  {
  }

  void Child_pskel::
  albumId (const ::std::string&)
  {
  }

  void Child_pskel::
  artistId (const ::std::string&)
  {
  }

  void Child_pskel::
  type ()
  {
  }

  void Child_pskel::
  bookmarkPosition (long long)
  {
  }

  void Child_pskel::
  post_Child ()
  {
  }

  // MediaType_pskel
  //

  void MediaType_pskel::
  post_MediaType ()
  {
  }

  // UserRating_pskel
  //

  void UserRating_pskel::
  post_UserRating ()
  {
  }

  // AverageRating_pskel
  //

  void AverageRating_pskel::
  post_AverageRating ()
  {
  }

  // NowPlaying_pskel
  //

  void NowPlaying_pskel::
  entry ()
  {
  }

  void NowPlaying_pskel::
  post_NowPlaying ()
  {
  }

  // NowPlayingEntry_pskel
  //

  void NowPlayingEntry_pskel::
  username (const ::std::string&)
  {
  }

  void NowPlayingEntry_pskel::
  minutesAgo (int)
  {
  }

  void NowPlayingEntry_pskel::
  playerId (int)
  {
  }

  void NowPlayingEntry_pskel::
  playerName (const ::std::string&)
  {
  }

  void NowPlayingEntry_pskel::
  post_NowPlayingEntry ()
  {
    post_Child ();
  }

  // SearchResult_pskel
  //

  void SearchResult_pskel::
  match ()
  {
  }

  void SearchResult_pskel::
  offset (int)
  {
  }

  void SearchResult_pskel::
  totalHits (int)
  {
  }

  void SearchResult_pskel::
  post_SearchResult ()
  {
  }

  // SearchResult2_pskel
  //

  void SearchResult2_pskel::
  artist ()
  {
  }

  void SearchResult2_pskel::
  album ()
  {
  }

  void SearchResult2_pskel::
  song ()
  {
  }

  void SearchResult2_pskel::
  post_SearchResult2 ()
  {
  }

  // SearchResult3_pskel
  //

  void SearchResult3_pskel::
  artist ()
  {
  }

  void SearchResult3_pskel::
  album ()
  {
  }

  void SearchResult3_pskel::
  song ()
  {
  }

  void SearchResult3_pskel::
  post_SearchResult3 ()
  {
  }

  // Playlists_pskel
  //

  void Playlists_pskel::
  playlist ()
  {
  }

  void Playlists_pskel::
  post_Playlists ()
  {
  }

  // Playlist_pskel
  //

  void Playlist_pskel::
  allowedUser (const ::std::string&)
  {
  }

  void Playlist_pskel::
  id (const ::std::string&)
  {
  }

  void Playlist_pskel::
  name (const ::std::string&)
  {
  }

  void Playlist_pskel::
  comment (const ::std::string&)
  {
  }

  void Playlist_pskel::
  owner (const ::std::string&)
  {
  }

  void Playlist_pskel::
  public_ (bool)
  {
  }

  void Playlist_pskel::
  songCount (int)
  {
  }

  void Playlist_pskel::
  duration (int)
  {
  }

  void Playlist_pskel::
  created (const ::xml_schema::date_time&)
  {
  }

  void Playlist_pskel::
  post_Playlist ()
  {
  }

  // PlaylistWithSongs_pskel
  //

  void PlaylistWithSongs_pskel::
  entry ()
  {
  }

  void PlaylistWithSongs_pskel::
  post_PlaylistWithSongs ()
  {
    post_Playlist ();
  }

  // JukeboxStatus_pskel
  //

  void JukeboxStatus_pskel::
  currentIndex (int)
  {
  }

  void JukeboxStatus_pskel::
  playing (bool)
  {
  }

  void JukeboxStatus_pskel::
  gain (float)
  {
  }

  void JukeboxStatus_pskel::
  position (int)
  {
  }

  void JukeboxStatus_pskel::
  post_JukeboxStatus ()
  {
  }

  // JukeboxPlaylist_pskel
  //

  void JukeboxPlaylist_pskel::
  entry ()
  {
  }

  void JukeboxPlaylist_pskel::
  post_JukeboxPlaylist ()
  {
    post_JukeboxStatus ();
  }

  // ChatMessages_pskel
  //

  void ChatMessages_pskel::
  chatMessage ()
  {
  }

  void ChatMessages_pskel::
  post_ChatMessages ()
  {
  }

  // ChatMessage_pskel
  //

  void ChatMessage_pskel::
  username (const ::std::string&)
  {
  }

  void ChatMessage_pskel::
  time (long long)
  {
  }

  void ChatMessage_pskel::
  message (const ::std::string&)
  {
  }

  void ChatMessage_pskel::
  post_ChatMessage ()
  {
  }

  // AlbumList_pskel
  //

  void AlbumList_pskel::
  album ()
  {
  }

  void AlbumList_pskel::
  post_AlbumList ()
  {
  }

  // AlbumList2_pskel
  //

  void AlbumList2_pskel::
  album ()
  {
  }

  void AlbumList2_pskel::
  post_AlbumList2 ()
  {
  }

  // Songs_pskel
  //

  void Songs_pskel::
  song ()
  {
  }

  void Songs_pskel::
  post_Songs ()
  {
  }

  // Lyrics_pskel
  //

  void Lyrics_pskel::
  artist (const ::std::string&)
  {
  }

  void Lyrics_pskel::
  title (const ::std::string&)
  {
  }

  void Lyrics_pskel::
  post_Lyrics ()
  {
  }

  // Podcasts_pskel
  //

  void Podcasts_pskel::
  channel ()
  {
  }

  void Podcasts_pskel::
  post_Podcasts ()
  {
  }

  // PodcastChannel_pskel
  //

  void PodcastChannel_pskel::
  episode ()
  {
  }

  void PodcastChannel_pskel::
  id (const ::std::string&)
  {
  }

  void PodcastChannel_pskel::
  url (const ::std::string&)
  {
  }

  void PodcastChannel_pskel::
  title (const ::std::string&)
  {
  }

  void PodcastChannel_pskel::
  description (const ::std::string&)
  {
  }

  void PodcastChannel_pskel::
  status ()
  {
  }

  void PodcastChannel_pskel::
  errorMessage (const ::std::string&)
  {
  }

  void PodcastChannel_pskel::
  post_PodcastChannel ()
  {
  }

  // PodcastEpisode_pskel
  //

  void PodcastEpisode_pskel::
  streamId (const ::std::string&)
  {
  }

  void PodcastEpisode_pskel::
  description (const ::std::string&)
  {
  }

  void PodcastEpisode_pskel::
  status ()
  {
  }

  void PodcastEpisode_pskel::
  publishDate (const ::xml_schema::date_time&)
  {
  }

  void PodcastEpisode_pskel::
  post_PodcastEpisode ()
  {
    post_Child ();
  }

  // PodcastStatus_pskel
  //

  void PodcastStatus_pskel::
  post_PodcastStatus ()
  {
  }

  // InternetRadioStations_pskel
  //

  void InternetRadioStations_pskel::
  internetRadioStation ()
  {
  }

  void InternetRadioStations_pskel::
  post_InternetRadioStations ()
  {
  }

  // InternetRadioStation_pskel
  //

  void InternetRadioStation_pskel::
  id (const ::std::string&)
  {
  }

  void InternetRadioStation_pskel::
  name (const ::std::string&)
  {
  }

  void InternetRadioStation_pskel::
  streamUrl (const ::std::string&)
  {
  }

  void InternetRadioStation_pskel::
  homePageUrl (const ::std::string&)
  {
  }

  void InternetRadioStation_pskel::
  post_InternetRadioStation ()
  {
  }

  // Bookmarks_pskel
  //

  void Bookmarks_pskel::
  bookmark ()
  {
  }

  void Bookmarks_pskel::
  post_Bookmarks ()
  {
  }

  // Bookmark_pskel
  //

  void Bookmark_pskel::
  entry ()
  {
  }

  void Bookmark_pskel::
  position (long long)
  {
  }

  void Bookmark_pskel::
  username (const ::std::string&)
  {
  }

  void Bookmark_pskel::
  comment (const ::std::string&)
  {
  }

  void Bookmark_pskel::
  created (const ::xml_schema::date_time&)
  {
  }

  void Bookmark_pskel::
  changed (const ::xml_schema::date_time&)
  {
  }

  void Bookmark_pskel::
  post_Bookmark ()
  {
  }

  // Shares_pskel
  //

  void Shares_pskel::
  share ()
  {
  }

  void Shares_pskel::
  post_Shares ()
  {
  }

  // Share_pskel
  //

  void Share_pskel::
  entry ()
  {
  }

  void Share_pskel::
  id (const ::std::string&)
  {
  }

  void Share_pskel::
  url (const ::std::string&)
  {
  }

  void Share_pskel::
  description (const ::std::string&)
  {
  }

  void Share_pskel::
  username (const ::std::string&)
  {
  }

  void Share_pskel::
  created (const ::xml_schema::date_time&)
  {
  }

  void Share_pskel::
  expires (const ::xml_schema::date_time&)
  {
  }

  void Share_pskel::
  lastVisited (const ::xml_schema::date_time&)
  {
  }

  void Share_pskel::
  visitCount (int)
  {
  }

  void Share_pskel::
  post_Share ()
  {
  }

  // Starred_pskel
  //

  void Starred_pskel::
  artist ()
  {
  }

  void Starred_pskel::
  album ()
  {
  }

  void Starred_pskel::
  song ()
  {
  }

  void Starred_pskel::
  post_Starred ()
  {
  }

  // Starred2_pskel
  //

  void Starred2_pskel::
  artist ()
  {
  }

  void Starred2_pskel::
  album ()
  {
  }

  void Starred2_pskel::
  song ()
  {
  }

  void Starred2_pskel::
  post_Starred2 ()
  {
  }

  // License_pskel
  //

  void License_pskel::
  valid (bool)
  {
  }

  void License_pskel::
  email (const ::std::string&)
  {
  }

  void License_pskel::
  key (const ::std::string&)
  {
  }

  void License_pskel::
  date (const ::xml_schema::date_time&)
  {
  }

  void License_pskel::
  post_License ()
  {
  }

  // Users_pskel
  //

  void Users_pskel::
  user ()
  {
  }

  void Users_pskel::
  post_Users ()
  {
  }

  // User_pskel
  //

  void User_pskel::
  username (const ::std::string&)
  {
  }

  void User_pskel::
  email (const ::std::string&)
  {
  }

  void User_pskel::
  scrobblingEnabled (bool)
  {
  }

  void User_pskel::
  adminRole (bool)
  {
  }

  void User_pskel::
  settingsRole (bool)
  {
  }

  void User_pskel::
  downloadRole (bool)
  {
  }

  void User_pskel::
  uploadRole (bool)
  {
  }

  void User_pskel::
  playlistRole (bool)
  {
  }

  void User_pskel::
  coverArtRole (bool)
  {
  }

  void User_pskel::
  commentRole (bool)
  {
  }

  void User_pskel::
  podcastRole (bool)
  {
  }

  void User_pskel::
  streamRole (bool)
  {
  }

  void User_pskel::
  jukeboxRole (bool)
  {
  }

  void User_pskel::
  shareRole (bool)
  {
  }

  void User_pskel::
  post_User ()
  {
  }

  // Error_pskel
  //

  void Error_pskel::
  code (int)
  {
  }

  void Error_pskel::
  message (const ::std::string&)
  {
  }

  void Error_pskel::
  post_Error ()
  {
  }
}

#include <cassert>

namespace restapi
{
  // Element validation and dispatch functions for Response_pskel.
  //
  bool Response_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    if (vd->func == 0 && vd->state == 0)
    {
      if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
        return true;
      else
        vd->state = 1;
    }

    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, ns, n, t, true);

      vd = vs.data + (vs.size - 1);

      if (vd->state == ~0UL)
        vd = vs.data + (--vs.size - 1);
      else
        break;
    }

    if (vd->func == 0)
    {
      if (vd->state != ~0UL)
      {
        unsigned long s = ~0UL;

        if (n == "musicFolders" &&
            ns == "http://subsonic.org/restapi")
          s = 0UL;
        else if (n == "indexes" &&
                 ns == "http://subsonic.org/restapi")
          s = 1UL;
        else if (n == "directory" &&
                 ns == "http://subsonic.org/restapi")
          s = 2UL;
        else if (n == "genres" &&
                 ns == "http://subsonic.org/restapi")
          s = 3UL;
        else if (n == "artists" &&
                 ns == "http://subsonic.org/restapi")
          s = 4UL;
        else if (n == "artist" &&
                 ns == "http://subsonic.org/restapi")
          s = 5UL;
        else if (n == "album" &&
                 ns == "http://subsonic.org/restapi")
          s = 6UL;
        else if (n == "song" &&
                 ns == "http://subsonic.org/restapi")
          s = 7UL;
        else if (n == "videos" &&
                 ns == "http://subsonic.org/restapi")
          s = 8UL;
        else if (n == "nowPlaying" &&
                 ns == "http://subsonic.org/restapi")
          s = 9UL;
        else if (n == "searchResult" &&
                 ns == "http://subsonic.org/restapi")
          s = 10UL;
        else if (n == "searchResult2" &&
                 ns == "http://subsonic.org/restapi")
          s = 11UL;
        else if (n == "searchResult3" &&
                 ns == "http://subsonic.org/restapi")
          s = 12UL;
        else if (n == "playlists" &&
                 ns == "http://subsonic.org/restapi")
          s = 13UL;
        else if (n == "playlist" &&
                 ns == "http://subsonic.org/restapi")
          s = 14UL;
        else if (n == "jukeboxStatus" &&
                 ns == "http://subsonic.org/restapi")
          s = 15UL;
        else if (n == "jukeboxPlaylist" &&
                 ns == "http://subsonic.org/restapi")
          s = 16UL;
        else if (n == "license" &&
                 ns == "http://subsonic.org/restapi")
          s = 17UL;
        else if (n == "users" &&
                 ns == "http://subsonic.org/restapi")
          s = 18UL;
        else if (n == "user" &&
                 ns == "http://subsonic.org/restapi")
          s = 19UL;
        else if (n == "chatMessages" &&
                 ns == "http://subsonic.org/restapi")
          s = 20UL;
        else if (n == "albumList" &&
                 ns == "http://subsonic.org/restapi")
          s = 21UL;
        else if (n == "albumList2" &&
                 ns == "http://subsonic.org/restapi")
          s = 22UL;
        else if (n == "randomSongs" &&
                 ns == "http://subsonic.org/restapi")
          s = 23UL;
        else if (n == "songsByGenre" &&
                 ns == "http://subsonic.org/restapi")
          s = 24UL;
        else if (n == "lyrics" &&
                 ns == "http://subsonic.org/restapi")
          s = 25UL;
        else if (n == "podcasts" &&
                 ns == "http://subsonic.org/restapi")
          s = 26UL;
        else if (n == "internetRadioStations" &&
                 ns == "http://subsonic.org/restapi")
          s = 27UL;
        else if (n == "bookmarks" &&
                 ns == "http://subsonic.org/restapi")
          s = 28UL;
        else if (n == "shares" &&
                 ns == "http://subsonic.org/restapi")
          s = 29UL;
        else if (n == "starred" &&
                 ns == "http://subsonic.org/restapi")
          s = 30UL;
        else if (n == "starred2" &&
                 ns == "http://subsonic.org/restapi")
          s = 31UL;
        else if (n == "error" &&
                 ns == "http://subsonic.org/restapi")
          s = 32UL;

        if (s != ~0UL)
        {
          vd->count++;
          vd->state = ~0UL;

          vd = vs.data + vs.size++;
          vd->func = &Response_pskel::choice_0;
          vd->state = s;
          vd->count = 0;

          this->choice_0 (vd->state, vd->count, ns, n, t, true);
        }
        else
        {
          return false;
        }
      }
      else
        return false;
    }

    return true;
  }

  bool Response_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size - 1];

    if (vd.func == 0 && vd.state == 0)
    {
      if (!::xml_schema::complex_content::_end_element_impl (ns, n))
        assert (false);
      return true;
    }

    assert (vd.func != 0);
    (this->*vd.func) (vd.state, vd.count, ns, n, 0, false);

    if (vd.state == ~0UL)
      vs.size--;

    return true;
  }

  void Response_pskel::
  _pre_e_validate ()
  {
    this->v_state_stack_.push ();
    static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size++];

    vd.func = 0;
    vd.state = 0;
    vd.count = 0;
  }

  void Response_pskel::
  _post_e_validate ()
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    ::xml_schema::ro_string empty;
    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, empty, empty, 0, true);
      assert (vd->state == ~0UL);
      vd = vs.data + (--vs.size - 1);
    }


    this->v_state_stack_.pop ();
  }

  void Response_pskel::
  choice_0 (unsigned long& state,
            unsigned long& count,
            const ::xml_schema::ro_string& ns,
            const ::xml_schema::ro_string& n,
            const ::xml_schema::ro_string* t,
            bool start)
  {
    XSD_UNUSED (count);
    XSD_UNUSED (ns);
    XSD_UNUSED (n);
    XSD_UNUSED (t);

    switch (state)
    {
      case 0UL:
      {
        if (start)
        {
          this->::xml_schema::complex_content::context_.top ().parser_ = this->musicFolders_parser_;

          if (this->musicFolders_parser_)
            this->musicFolders_parser_->pre ();
        }
        else
        {
          if (this->musicFolders_parser_)
          {
            this->musicFolders_parser_->post_MusicFolders ();
            this->musicFolders ();
          }

          state = ~0UL;
        }

        break;
      }
      case 1UL:
      {
        if (start)
        {
          this->::xml_schema::complex_content::context_.top ().parser_ = this->indexes_parser_;

          if (this->indexes_parser_)
            this->indexes_parser_->pre ();
        }
        else
        {
          if (this->indexes_parser_)
          {
            this->indexes_parser_->post_Indexes ();
            this->indexes ();
          }

          state = ~0UL;
        }

        break;
      }
      case 2UL:
      {
        if (start)
        {
          this->::xml_schema::complex_content::context_.top ().parser_ = this->directory_parser_;

          if (this->directory_parser_)
            this->directory_parser_->pre ();
        }
        else
        {
          if (this->directory_parser_)
          {
            this->directory_parser_->post_Directory ();
            this->directory ();
          }

          state = ~0UL;
        }

        break;
      }
      case 3UL:
      {
        if (start)
        {
          this->::xml_schema::complex_content::context_.top ().parser_ = this->genres_parser_;

          if (this->genres_parser_)
            this->genres_parser_->pre ();
        }
        else
        {
          if (this->genres_parser_)
          {
            this->genres_parser_->post_Genres ();
            this->genres ();
          }

          state = ~0UL;
        }

        break;
      }
      case 4UL:
      {
        if (start)
        {
          this->::xml_schema::complex_content::context_.top ().parser_ = this->artists_parser_;

          if (this->artists_parser_)
            this->artists_parser_->pre ();
        }
        else
        {
          if (this->artists_parser_)
          {
            this->artists_parser_->post_ArtistsID3 ();
            this->artists ();
          }

          state = ~0UL;
        }

        break;
      }
      case 5UL:
      {
        if (start)
        {
          this->::xml_schema::complex_content::context_.top ().parser_ = this->artist_parser_;

          if (this->artist_parser_)
            this->artist_parser_->pre ();
        }
        else
        {
          if (this->artist_parser_)
          {
            this->artist_parser_->post_ArtistWithAlbumsID3 ();
            this->artist ();
          }

          state = ~0UL;
        }

        break;
      }
      case 6UL:
      {
        if (start)
        {
          this->::xml_schema::complex_content::context_.top ().parser_ = this->album_parser_;

          if (this->album_parser_)
            this->album_parser_->pre ();
        }
        else
        {
          if (this->album_parser_)
          {
            this->album_parser_->post_AlbumWithSongsID3 ();
            this->album ();
          }

          state = ~0UL;
        }

        break;
      }
      case 7UL:
      {
        if (start)
        {
          this->::xml_schema::complex_content::context_.top ().parser_ = this->song_parser_;

          if (this->song_parser_)
            this->song_parser_->pre ();
        }
        else
        {
          if (this->song_parser_)
          {
            this->song_parser_->post_Child ();
            this->song ();
          }

          state = ~0UL;
        }

        break;
      }
      case 8UL:
      {
        if (start)
        {
          this->::xml_schema::complex_content::context_.top ().parser_ = this->videos_parser_;

          if (this->videos_parser_)
            this->videos_parser_->pre ();
        }
        else
        {
          if (this->videos_parser_)
          {
            this->videos_parser_->post_Videos ();
            this->videos ();
          }

          state = ~0UL;
        }

        break;
      }
      case 9UL:
      {
        if (start)
        {
          this->::xml_schema::complex_content::context_.top ().parser_ = this->nowPlaying_parser_;

          if (this->nowPlaying_parser_)
            this->nowPlaying_parser_->pre ();
        }
        else
        {
          if (this->nowPlaying_parser_)
          {
            this->nowPlaying_parser_->post_NowPlaying ();
            this->nowPlaying ();
          }

          state = ~0UL;
        }

        break;
      }
      case 10UL:
      {
        if (start)
        {
          this->::xml_schema::complex_content::context_.top ().parser_ = this->searchResult_parser_;

          if (this->searchResult_parser_)
            this->searchResult_parser_->pre ();
        }
        else
        {
          if (this->searchResult_parser_)
          {
            this->searchResult_parser_->post_SearchResult ();
            this->searchResult ();
          }

          state = ~0UL;
        }

        break;
      }
      case 11UL:
      {
        if (start)
        {
          this->::xml_schema::complex_content::context_.top ().parser_ = this->searchResult2_parser_;

          if (this->searchResult2_parser_)
            this->searchResult2_parser_->pre ();
        }
        else
        {
          if (this->searchResult2_parser_)
          {
            this->searchResult2_parser_->post_SearchResult2 ();
            this->searchResult2 ();
          }

          state = ~0UL;
        }

        break;
      }
      case 12UL:
      {
        if (start)
        {
          this->::xml_schema::complex_content::context_.top ().parser_ = this->searchResult3_parser_;

          if (this->searchResult3_parser_)
            this->searchResult3_parser_->pre ();
        }
        else
        {
          if (this->searchResult3_parser_)
          {
            this->searchResult3_parser_->post_SearchResult3 ();
            this->searchResult3 ();
          }

          state = ~0UL;
        }

        break;
      }
      case 13UL:
      {
        if (start)
        {
          this->::xml_schema::complex_content::context_.top ().parser_ = this->playlists_parser_;

          if (this->playlists_parser_)
            this->playlists_parser_->pre ();
        }
        else
        {
          if (this->playlists_parser_)
          {
            this->playlists_parser_->post_Playlists ();
            this->playlists ();
          }

          state = ~0UL;
        }

        break;
      }
      case 14UL:
      {
        if (start)
        {
          this->::xml_schema::complex_content::context_.top ().parser_ = this->playlist_parser_;

          if (this->playlist_parser_)
            this->playlist_parser_->pre ();
        }
        else
        {
          if (this->playlist_parser_)
          {
            this->playlist_parser_->post_PlaylistWithSongs ();
            this->playlist ();
          }

          state = ~0UL;
        }

        break;
      }
      case 15UL:
      {
        if (start)
        {
          this->::xml_schema::complex_content::context_.top ().parser_ = this->jukeboxStatus_parser_;

          if (this->jukeboxStatus_parser_)
            this->jukeboxStatus_parser_->pre ();
        }
        else
        {
          if (this->jukeboxStatus_parser_)
          {
            this->jukeboxStatus_parser_->post_JukeboxStatus ();
            this->jukeboxStatus ();
          }

          state = ~0UL;
        }

        break;
      }
      case 16UL:
      {
        if (start)
        {
          this->::xml_schema::complex_content::context_.top ().parser_ = this->jukeboxPlaylist_parser_;

          if (this->jukeboxPlaylist_parser_)
            this->jukeboxPlaylist_parser_->pre ();
        }
        else
        {
          if (this->jukeboxPlaylist_parser_)
          {
            this->jukeboxPlaylist_parser_->post_JukeboxPlaylist ();
            this->jukeboxPlaylist ();
          }

          state = ~0UL;
        }

        break;
      }
      case 17UL:
      {
        if (start)
        {
          this->::xml_schema::complex_content::context_.top ().parser_ = this->license_parser_;

          if (this->license_parser_)
            this->license_parser_->pre ();
        }
        else
        {
          if (this->license_parser_)
          {
            this->license_parser_->post_License ();
            this->license ();
          }

          state = ~0UL;
        }

        break;
      }
      case 18UL:
      {
        if (start)
        {
          this->::xml_schema::complex_content::context_.top ().parser_ = this->users_parser_;

          if (this->users_parser_)
            this->users_parser_->pre ();
        }
        else
        {
          if (this->users_parser_)
          {
            this->users_parser_->post_Users ();
            this->users ();
          }

          state = ~0UL;
        }

        break;
      }
      case 19UL:
      {
        if (start)
        {
          this->::xml_schema::complex_content::context_.top ().parser_ = this->user_parser_;

          if (this->user_parser_)
            this->user_parser_->pre ();
        }
        else
        {
          if (this->user_parser_)
          {
            this->user_parser_->post_User ();
            this->user ();
          }

          state = ~0UL;
        }

        break;
      }
      case 20UL:
      {
        if (start)
        {
          this->::xml_schema::complex_content::context_.top ().parser_ = this->chatMessages_parser_;

          if (this->chatMessages_parser_)
            this->chatMessages_parser_->pre ();
        }
        else
        {
          if (this->chatMessages_parser_)
          {
            this->chatMessages_parser_->post_ChatMessages ();
            this->chatMessages ();
          }

          state = ~0UL;
        }

        break;
      }
      case 21UL:
      {
        if (start)
        {
          this->::xml_schema::complex_content::context_.top ().parser_ = this->albumList_parser_;

          if (this->albumList_parser_)
            this->albumList_parser_->pre ();
        }
        else
        {
          if (this->albumList_parser_)
          {
            this->albumList_parser_->post_AlbumList ();
            this->albumList ();
          }

          state = ~0UL;
        }

        break;
      }
      case 22UL:
      {
        if (start)
        {
          this->::xml_schema::complex_content::context_.top ().parser_ = this->albumList2_parser_;

          if (this->albumList2_parser_)
            this->albumList2_parser_->pre ();
        }
        else
        {
          if (this->albumList2_parser_)
          {
            this->albumList2_parser_->post_AlbumList2 ();
            this->albumList2 ();
          }

          state = ~0UL;
        }

        break;
      }
      case 23UL:
      {
        if (start)
        {
          this->::xml_schema::complex_content::context_.top ().parser_ = this->randomSongs_parser_;

          if (this->randomSongs_parser_)
            this->randomSongs_parser_->pre ();
        }
        else
        {
          if (this->randomSongs_parser_)
          {
            this->randomSongs_parser_->post_Songs ();
            this->randomSongs ();
          }

          state = ~0UL;
        }

        break;
      }
      case 24UL:
      {
        if (start)
        {
          this->::xml_schema::complex_content::context_.top ().parser_ = this->songsByGenre_parser_;

          if (this->songsByGenre_parser_)
            this->songsByGenre_parser_->pre ();
        }
        else
        {
          if (this->songsByGenre_parser_)
          {
            this->songsByGenre_parser_->post_Songs ();
            this->songsByGenre ();
          }

          state = ~0UL;
        }

        break;
      }
      case 25UL:
      {
        if (start)
        {
          this->::xml_schema::complex_content::context_.top ().parser_ = this->lyrics_parser_;

          if (this->lyrics_parser_)
            this->lyrics_parser_->pre ();
        }
        else
        {
          if (this->lyrics_parser_)
          {
            this->lyrics_parser_->post_Lyrics ();
            this->lyrics ();
          }

          state = ~0UL;
        }

        break;
      }
      case 26UL:
      {
        if (start)
        {
          this->::xml_schema::complex_content::context_.top ().parser_ = this->podcasts_parser_;

          if (this->podcasts_parser_)
            this->podcasts_parser_->pre ();
        }
        else
        {
          if (this->podcasts_parser_)
          {
            this->podcasts_parser_->post_Podcasts ();
            this->podcasts ();
          }

          state = ~0UL;
        }

        break;
      }
      case 27UL:
      {
        if (start)
        {
          this->::xml_schema::complex_content::context_.top ().parser_ = this->internetRadioStations_parser_;

          if (this->internetRadioStations_parser_)
            this->internetRadioStations_parser_->pre ();
        }
        else
        {
          if (this->internetRadioStations_parser_)
          {
            this->internetRadioStations_parser_->post_InternetRadioStations ();
            this->internetRadioStations ();
          }

          state = ~0UL;
        }

        break;
      }
      case 28UL:
      {
        if (start)
        {
          this->::xml_schema::complex_content::context_.top ().parser_ = this->bookmarks_parser_;

          if (this->bookmarks_parser_)
            this->bookmarks_parser_->pre ();
        }
        else
        {
          if (this->bookmarks_parser_)
          {
            this->bookmarks_parser_->post_Bookmarks ();
            this->bookmarks ();
          }

          state = ~0UL;
        }

        break;
      }
      case 29UL:
      {
        if (start)
        {
          this->::xml_schema::complex_content::context_.top ().parser_ = this->shares_parser_;

          if (this->shares_parser_)
            this->shares_parser_->pre ();
        }
        else
        {
          if (this->shares_parser_)
          {
            this->shares_parser_->post_Shares ();
            this->shares ();
          }

          state = ~0UL;
        }

        break;
      }
      case 30UL:
      {
        if (start)
        {
          this->::xml_schema::complex_content::context_.top ().parser_ = this->starred_parser_;

          if (this->starred_parser_)
            this->starred_parser_->pre ();
        }
        else
        {
          if (this->starred_parser_)
          {
            this->starred_parser_->post_Starred ();
            this->starred ();
          }

          state = ~0UL;
        }

        break;
      }
      case 31UL:
      {
        if (start)
        {
          this->::xml_schema::complex_content::context_.top ().parser_ = this->starred2_parser_;

          if (this->starred2_parser_)
            this->starred2_parser_->pre ();
        }
        else
        {
          if (this->starred2_parser_)
          {
            this->starred2_parser_->post_Starred2 ();
            this->starred2 ();
          }

          state = ~0UL;
        }

        break;
      }
      case 32UL:
      {
        if (start)
        {
          this->::xml_schema::complex_content::context_.top ().parser_ = this->error_parser_;

          if (this->error_parser_)
            this->error_parser_->pre ();
        }
        else
        {
          if (this->error_parser_)
          {
            this->error_parser_->post_Error ();
            this->error ();
          }

          state = ~0UL;
        }

        break;
      }
    }
  }

  // Element validation and dispatch functions for MusicFolders_pskel.
  //
  bool MusicFolders_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    if (vd->func == 0 && vd->state == 0)
    {
      if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
        return true;
      else
        vd->state = 1;
    }

    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, ns, n, t, true);

      vd = vs.data + (vs.size - 1);

      if (vd->state == ~0UL)
        vd = vs.data + (--vs.size - 1);
      else
        break;
    }

    if (vd->func == 0)
    {
      if (vd->state != ~0UL)
      {
        unsigned long s = ~0UL;

        if (n == "musicFolder" &&
            ns == "http://subsonic.org/restapi")
          s = 0UL;

        if (s != ~0UL)
        {
          vd->count++;
          vd->state = ~0UL;

          vd = vs.data + vs.size++;
          vd->func = &MusicFolders_pskel::sequence_0;
          vd->state = s;
          vd->count = 0;

          this->sequence_0 (vd->state, vd->count, ns, n, t, true);
        }
        else
        {
          return false;
        }
      }
      else
        return false;
    }

    return true;
  }

  bool MusicFolders_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size - 1];

    if (vd.func == 0 && vd.state == 0)
    {
      if (!::xml_schema::complex_content::_end_element_impl (ns, n))
        assert (false);
      return true;
    }

    assert (vd.func != 0);
    (this->*vd.func) (vd.state, vd.count, ns, n, 0, false);

    if (vd.state == ~0UL)
      vs.size--;

    return true;
  }

  void MusicFolders_pskel::
  _pre_e_validate ()
  {
    this->v_state_stack_.push ();
    static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size++];

    vd.func = 0;
    vd.state = 0;
    vd.count = 0;
  }

  void MusicFolders_pskel::
  _post_e_validate ()
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    ::xml_schema::ro_string empty;
    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, empty, empty, 0, true);
      assert (vd->state == ~0UL);
      vd = vs.data + (--vs.size - 1);
    }


    this->v_state_stack_.pop ();
  }

  void MusicFolders_pskel::
  sequence_0 (unsigned long& state,
              unsigned long& count,
              const ::xml_schema::ro_string& ns,
              const ::xml_schema::ro_string& n,
              const ::xml_schema::ro_string* t,
              bool start)
  {
    XSD_UNUSED (t);

    switch (state)
    {
      case 0UL:
      {
        if (n == "musicFolder" &&
            ns == "http://subsonic.org/restapi")
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->musicFolder_parser_;

            if (this->musicFolder_parser_)
              this->musicFolder_parser_->pre ();
          }
          else
          {
            if (this->musicFolder_parser_)
            {
              this->musicFolder_parser_->post_MusicFolder ();
              this->musicFolder ();
            }

            count++;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = ~0UL;
          // Fall through.
        }
      }
      case ~0UL:
        break;
    }
  }

  // Element validation and dispatch functions for Indexes_pskel.
  //
  bool Indexes_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    if (vd->func == 0 && vd->state == 0)
    {
      if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
        return true;
      else
        vd->state = 1;
    }

    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, ns, n, t, true);

      vd = vs.data + (vs.size - 1);

      if (vd->state == ~0UL)
        vd = vs.data + (--vs.size - 1);
      else
        break;
    }

    if (vd->func == 0)
    {
      if (vd->state != ~0UL)
      {
        unsigned long s = ~0UL;

        if (n == "shortcut" &&
            ns == "http://subsonic.org/restapi")
          s = 0UL;
        else if (n == "index" &&
                 ns == "http://subsonic.org/restapi")
          s = 1UL;
        else if (n == "child" &&
                 ns == "http://subsonic.org/restapi")
          s = 2UL;

        if (s != ~0UL)
        {
          vd->count++;
          vd->state = ~0UL;

          vd = vs.data + vs.size++;
          vd->func = &Indexes_pskel::sequence_0;
          vd->state = s;
          vd->count = 0;

          this->sequence_0 (vd->state, vd->count, ns, n, t, true);
        }
        else
        {
          return false;
        }
      }
      else
        return false;
    }

    return true;
  }

  bool Indexes_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size - 1];

    if (vd.func == 0 && vd.state == 0)
    {
      if (!::xml_schema::complex_content::_end_element_impl (ns, n))
        assert (false);
      return true;
    }

    assert (vd.func != 0);
    (this->*vd.func) (vd.state, vd.count, ns, n, 0, false);

    if (vd.state == ~0UL)
      vs.size--;

    return true;
  }

  void Indexes_pskel::
  _pre_e_validate ()
  {
    this->v_state_stack_.push ();
    static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size++];

    vd.func = 0;
    vd.state = 0;
    vd.count = 0;
  }

  void Indexes_pskel::
  _post_e_validate ()
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    ::xml_schema::ro_string empty;
    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, empty, empty, 0, true);
      assert (vd->state == ~0UL);
      vd = vs.data + (--vs.size - 1);
    }


    this->v_state_stack_.pop ();
  }

  void Indexes_pskel::
  sequence_0 (unsigned long& state,
              unsigned long& count,
              const ::xml_schema::ro_string& ns,
              const ::xml_schema::ro_string& n,
              const ::xml_schema::ro_string* t,
              bool start)
  {
    XSD_UNUSED (t);

    switch (state)
    {
      case 0UL:
      {
        if (n == "shortcut" &&
            ns == "http://subsonic.org/restapi")
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->shortcut_parser_;

            if (this->shortcut_parser_)
              this->shortcut_parser_->pre ();
          }
          else
          {
            if (this->shortcut_parser_)
            {
              this->shortcut_parser_->post_Artist ();
              this->shortcut ();
            }

            count++;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 1UL;
          // Fall through.
        }
      }
      case 1UL:
      {
        if (n == "index" &&
            ns == "http://subsonic.org/restapi")
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->index_parser_;

            if (this->index_parser_)
              this->index_parser_->pre ();
          }
          else
          {
            if (this->index_parser_)
            {
              this->index_parser_->post_Index ();
              this->index ();
            }

            count++;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 2UL;
          // Fall through.
        }
      }
      case 2UL:
      {
        if (n == "child" &&
            ns == "http://subsonic.org/restapi")
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->child_parser_;

            if (this->child_parser_)
              this->child_parser_->pre ();
          }
          else
          {
            if (this->child_parser_)
            {
              this->child_parser_->post_Child ();
              this->child ();
            }

            count++;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = ~0UL;
          // Fall through.
        }
      }
      case ~0UL:
        break;
    }
  }

  // Element validation and dispatch functions for Index_pskel.
  //
  bool Index_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    if (vd->func == 0 && vd->state == 0)
    {
      if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
        return true;
      else
        vd->state = 1;
    }

    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, ns, n, t, true);

      vd = vs.data + (vs.size - 1);

      if (vd->state == ~0UL)
        vd = vs.data + (--vs.size - 1);
      else
        break;
    }

    if (vd->func == 0)
    {
      if (vd->state != ~0UL)
      {
        unsigned long s = ~0UL;

        if (n == "artist" &&
            ns == "http://subsonic.org/restapi")
          s = 0UL;

        if (s != ~0UL)
        {
          vd->count++;
          vd->state = ~0UL;

          vd = vs.data + vs.size++;
          vd->func = &Index_pskel::sequence_0;
          vd->state = s;
          vd->count = 0;

          this->sequence_0 (vd->state, vd->count, ns, n, t, true);
        }
        else
        {
          return false;
        }
      }
      else
        return false;
    }

    return true;
  }

  bool Index_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size - 1];

    if (vd.func == 0 && vd.state == 0)
    {
      if (!::xml_schema::complex_content::_end_element_impl (ns, n))
        assert (false);
      return true;
    }

    assert (vd.func != 0);
    (this->*vd.func) (vd.state, vd.count, ns, n, 0, false);

    if (vd.state == ~0UL)
      vs.size--;

    return true;
  }

  void Index_pskel::
  _pre_e_validate ()
  {
    this->v_state_stack_.push ();
    static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size++];

    vd.func = 0;
    vd.state = 0;
    vd.count = 0;
  }

  void Index_pskel::
  _post_e_validate ()
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    ::xml_schema::ro_string empty;
    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, empty, empty, 0, true);
      assert (vd->state == ~0UL);
      vd = vs.data + (--vs.size - 1);
    }


    this->v_state_stack_.pop ();
  }

  void Index_pskel::
  sequence_0 (unsigned long& state,
              unsigned long& count,
              const ::xml_schema::ro_string& ns,
              const ::xml_schema::ro_string& n,
              const ::xml_schema::ro_string* t,
              bool start)
  {
    XSD_UNUSED (t);

    switch (state)
    {
      case 0UL:
      {
        if (n == "artist" &&
            ns == "http://subsonic.org/restapi")
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->artist_parser_;

            if (this->artist_parser_)
              this->artist_parser_->pre ();
          }
          else
          {
            if (this->artist_parser_)
            {
              this->artist_parser_->post_Artist ();
              this->artist ();
            }

            count++;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = ~0UL;
          // Fall through.
        }
      }
      case ~0UL:
        break;
    }
  }

  // Element validation and dispatch functions for Genres_pskel.
  //
  bool Genres_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    if (vd->func == 0 && vd->state == 0)
    {
      if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
        return true;
      else
        vd->state = 1;
    }

    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, ns, n, t, true);

      vd = vs.data + (vs.size - 1);

      if (vd->state == ~0UL)
        vd = vs.data + (--vs.size - 1);
      else
        break;
    }

    if (vd->func == 0)
    {
      if (vd->state != ~0UL)
      {
        unsigned long s = ~0UL;

        if (n == "genre" &&
            ns == "http://subsonic.org/restapi")
          s = 0UL;

        if (s != ~0UL)
        {
          vd->count++;
          vd->state = ~0UL;

          vd = vs.data + vs.size++;
          vd->func = &Genres_pskel::sequence_0;
          vd->state = s;
          vd->count = 0;

          this->sequence_0 (vd->state, vd->count, ns, n, t, true);
        }
        else
        {
          return false;
        }
      }
      else
        return false;
    }

    return true;
  }

  bool Genres_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size - 1];

    if (vd.func == 0 && vd.state == 0)
    {
      if (!::xml_schema::complex_content::_end_element_impl (ns, n))
        assert (false);
      return true;
    }

    assert (vd.func != 0);
    (this->*vd.func) (vd.state, vd.count, ns, n, 0, false);

    if (vd.state == ~0UL)
      vs.size--;

    return true;
  }

  void Genres_pskel::
  _pre_e_validate ()
  {
    this->v_state_stack_.push ();
    static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size++];

    vd.func = 0;
    vd.state = 0;
    vd.count = 0;
  }

  void Genres_pskel::
  _post_e_validate ()
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    ::xml_schema::ro_string empty;
    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, empty, empty, 0, true);
      assert (vd->state == ~0UL);
      vd = vs.data + (--vs.size - 1);
    }


    this->v_state_stack_.pop ();
  }

  void Genres_pskel::
  sequence_0 (unsigned long& state,
              unsigned long& count,
              const ::xml_schema::ro_string& ns,
              const ::xml_schema::ro_string& n,
              const ::xml_schema::ro_string* t,
              bool start)
  {
    XSD_UNUSED (t);

    switch (state)
    {
      case 0UL:
      {
        if (n == "genre" &&
            ns == "http://subsonic.org/restapi")
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->genre_parser_;

            if (this->genre_parser_)
              this->genre_parser_->pre ();
          }
          else
          {
            if (this->genre_parser_)
            {
              this->genre_parser_->post_Genre ();
              this->genre ();
            }

            count++;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = ~0UL;
          // Fall through.
        }
      }
      case ~0UL:
        break;
    }
  }

  // Element validation and dispatch functions for ArtistsID3_pskel.
  //
  bool ArtistsID3_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    if (vd->func == 0 && vd->state == 0)
    {
      if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
        return true;
      else
        vd->state = 1;
    }

    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, ns, n, t, true);

      vd = vs.data + (vs.size - 1);

      if (vd->state == ~0UL)
        vd = vs.data + (--vs.size - 1);
      else
        break;
    }

    if (vd->func == 0)
    {
      if (vd->state != ~0UL)
      {
        unsigned long s = ~0UL;

        if (n == "index" &&
            ns == "http://subsonic.org/restapi")
          s = 0UL;

        if (s != ~0UL)
        {
          vd->count++;
          vd->state = ~0UL;

          vd = vs.data + vs.size++;
          vd->func = &ArtistsID3_pskel::sequence_0;
          vd->state = s;
          vd->count = 0;

          this->sequence_0 (vd->state, vd->count, ns, n, t, true);
        }
        else
        {
          return false;
        }
      }
      else
        return false;
    }

    return true;
  }

  bool ArtistsID3_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size - 1];

    if (vd.func == 0 && vd.state == 0)
    {
      if (!::xml_schema::complex_content::_end_element_impl (ns, n))
        assert (false);
      return true;
    }

    assert (vd.func != 0);
    (this->*vd.func) (vd.state, vd.count, ns, n, 0, false);

    if (vd.state == ~0UL)
      vs.size--;

    return true;
  }

  void ArtistsID3_pskel::
  _pre_e_validate ()
  {
    this->v_state_stack_.push ();
    static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size++];

    vd.func = 0;
    vd.state = 0;
    vd.count = 0;
  }

  void ArtistsID3_pskel::
  _post_e_validate ()
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    ::xml_schema::ro_string empty;
    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, empty, empty, 0, true);
      assert (vd->state == ~0UL);
      vd = vs.data + (--vs.size - 1);
    }


    this->v_state_stack_.pop ();
  }

  void ArtistsID3_pskel::
  sequence_0 (unsigned long& state,
              unsigned long& count,
              const ::xml_schema::ro_string& ns,
              const ::xml_schema::ro_string& n,
              const ::xml_schema::ro_string* t,
              bool start)
  {
    XSD_UNUSED (t);

    switch (state)
    {
      case 0UL:
      {
        if (n == "index" &&
            ns == "http://subsonic.org/restapi")
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->index_parser_;

            if (this->index_parser_)
              this->index_parser_->pre ();
          }
          else
          {
            if (this->index_parser_)
            {
              this->index_parser_->post_IndexID3 ();
              this->index ();
            }

            count++;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = ~0UL;
          // Fall through.
        }
      }
      case ~0UL:
        break;
    }
  }

  // Element validation and dispatch functions for IndexID3_pskel.
  //
  bool IndexID3_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    if (vd->func == 0 && vd->state == 0)
    {
      if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
        return true;
      else
        vd->state = 1;
    }

    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, ns, n, t, true);

      vd = vs.data + (vs.size - 1);

      if (vd->state == ~0UL)
        vd = vs.data + (--vs.size - 1);
      else
        break;
    }

    if (vd->func == 0)
    {
      if (vd->state != ~0UL)
      {
        unsigned long s = ~0UL;

        if (n == "artist" &&
            ns == "http://subsonic.org/restapi")
          s = 0UL;

        if (s != ~0UL)
        {
          vd->count++;
          vd->state = ~0UL;

          vd = vs.data + vs.size++;
          vd->func = &IndexID3_pskel::sequence_0;
          vd->state = s;
          vd->count = 0;

          this->sequence_0 (vd->state, vd->count, ns, n, t, true);
        }
        else
        {
          return false;
        }
      }
      else
        return false;
    }

    return true;
  }

  bool IndexID3_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size - 1];

    if (vd.func == 0 && vd.state == 0)
    {
      if (!::xml_schema::complex_content::_end_element_impl (ns, n))
        assert (false);
      return true;
    }

    assert (vd.func != 0);
    (this->*vd.func) (vd.state, vd.count, ns, n, 0, false);

    if (vd.state == ~0UL)
      vs.size--;

    return true;
  }

  void IndexID3_pskel::
  _pre_e_validate ()
  {
    this->v_state_stack_.push ();
    static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size++];

    vd.func = 0;
    vd.state = 0;
    vd.count = 0;
  }

  void IndexID3_pskel::
  _post_e_validate ()
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    ::xml_schema::ro_string empty;
    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, empty, empty, 0, true);
      assert (vd->state == ~0UL);
      vd = vs.data + (--vs.size - 1);
    }


    this->v_state_stack_.pop ();
  }

  void IndexID3_pskel::
  sequence_0 (unsigned long& state,
              unsigned long& count,
              const ::xml_schema::ro_string& ns,
              const ::xml_schema::ro_string& n,
              const ::xml_schema::ro_string* t,
              bool start)
  {
    XSD_UNUSED (t);

    switch (state)
    {
      case 0UL:
      {
        if (n == "artist" &&
            ns == "http://subsonic.org/restapi")
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->artist_parser_;

            if (this->artist_parser_)
              this->artist_parser_->pre ();
          }
          else
          {
            if (this->artist_parser_)
            {
              this->artist_parser_->post_ArtistID3 ();
              this->artist ();
            }

            count++;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = ~0UL;
          // Fall through.
        }
      }
      case ~0UL:
        break;
    }
  }

  // Element validation and dispatch functions for ArtistWithAlbumsID3_pskel.
  //
  bool ArtistWithAlbumsID3_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    if (vd->func == 0 && vd->state == 0)
    {
      if (this->::restapi::ArtistID3_pskel::_start_element_impl (ns, n, t))
        return true;
      else
        vd->state = 1;
    }

    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, ns, n, t, true);

      vd = vs.data + (vs.size - 1);

      if (vd->state == ~0UL)
        vd = vs.data + (--vs.size - 1);
      else
        break;
    }

    if (vd->func == 0)
    {
      if (vd->state != ~0UL)
      {
        unsigned long s = ~0UL;

        if (n == "album" &&
            ns == "http://subsonic.org/restapi")
          s = 0UL;

        if (s != ~0UL)
        {
          vd->count++;
          vd->state = ~0UL;

          vd = vs.data + vs.size++;
          vd->func = &ArtistWithAlbumsID3_pskel::sequence_0;
          vd->state = s;
          vd->count = 0;

          this->sequence_0 (vd->state, vd->count, ns, n, t, true);
        }
        else
        {
          return false;
        }
      }
      else
        return false;
    }

    return true;
  }

  bool ArtistWithAlbumsID3_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size - 1];

    if (vd.func == 0 && vd.state == 0)
    {
      if (!::restapi::ArtistID3_pskel::_end_element_impl (ns, n))
        assert (false);
      return true;
    }

    assert (vd.func != 0);
    (this->*vd.func) (vd.state, vd.count, ns, n, 0, false);

    if (vd.state == ~0UL)
      vs.size--;

    return true;
  }

  void ArtistWithAlbumsID3_pskel::
  _pre_e_validate ()
  {
    this->v_state_stack_.push ();
    static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size++];

    vd.func = 0;
    vd.state = 0;
    vd.count = 0;

    ::restapi::ArtistID3_pskel::_pre_e_validate ();
  }

  void ArtistWithAlbumsID3_pskel::
  _post_e_validate ()
  {
    ::restapi::ArtistID3_pskel::_post_e_validate ();

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    ::xml_schema::ro_string empty;
    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, empty, empty, 0, true);
      assert (vd->state == ~0UL);
      vd = vs.data + (--vs.size - 1);
    }


    this->v_state_stack_.pop ();
  }

  void ArtistWithAlbumsID3_pskel::
  sequence_0 (unsigned long& state,
              unsigned long& count,
              const ::xml_schema::ro_string& ns,
              const ::xml_schema::ro_string& n,
              const ::xml_schema::ro_string* t,
              bool start)
  {
    XSD_UNUSED (t);

    switch (state)
    {
      case 0UL:
      {
        if (n == "album" &&
            ns == "http://subsonic.org/restapi")
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->album_parser_;

            if (this->album_parser_)
              this->album_parser_->pre ();
          }
          else
          {
            if (this->album_parser_)
            {
              this->album_parser_->post_AlbumID3 ();
              this->album ();
            }

            count++;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = ~0UL;
          // Fall through.
        }
      }
      case ~0UL:
        break;
    }
  }

  // Element validation and dispatch functions for AlbumWithSongsID3_pskel.
  //
  bool AlbumWithSongsID3_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    if (vd->func == 0 && vd->state == 0)
    {
      if (this->::restapi::AlbumID3_pskel::_start_element_impl (ns, n, t))
        return true;
      else
        vd->state = 1;
    }

    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, ns, n, t, true);

      vd = vs.data + (vs.size - 1);

      if (vd->state == ~0UL)
        vd = vs.data + (--vs.size - 1);
      else
        break;
    }

    if (vd->func == 0)
    {
      if (vd->state != ~0UL)
      {
        unsigned long s = ~0UL;

        if (n == "song" &&
            ns == "http://subsonic.org/restapi")
          s = 0UL;

        if (s != ~0UL)
        {
          vd->count++;
          vd->state = ~0UL;

          vd = vs.data + vs.size++;
          vd->func = &AlbumWithSongsID3_pskel::sequence_0;
          vd->state = s;
          vd->count = 0;

          this->sequence_0 (vd->state, vd->count, ns, n, t, true);
        }
        else
        {
          return false;
        }
      }
      else
        return false;
    }

    return true;
  }

  bool AlbumWithSongsID3_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size - 1];

    if (vd.func == 0 && vd.state == 0)
    {
      if (!::restapi::AlbumID3_pskel::_end_element_impl (ns, n))
        assert (false);
      return true;
    }

    assert (vd.func != 0);
    (this->*vd.func) (vd.state, vd.count, ns, n, 0, false);

    if (vd.state == ~0UL)
      vs.size--;

    return true;
  }

  void AlbumWithSongsID3_pskel::
  _pre_e_validate ()
  {
    this->v_state_stack_.push ();
    static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size++];

    vd.func = 0;
    vd.state = 0;
    vd.count = 0;

    ::restapi::AlbumID3_pskel::_pre_e_validate ();
  }

  void AlbumWithSongsID3_pskel::
  _post_e_validate ()
  {
    ::restapi::AlbumID3_pskel::_post_e_validate ();

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    ::xml_schema::ro_string empty;
    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, empty, empty, 0, true);
      assert (vd->state == ~0UL);
      vd = vs.data + (--vs.size - 1);
    }


    this->v_state_stack_.pop ();
  }

  void AlbumWithSongsID3_pskel::
  sequence_0 (unsigned long& state,
              unsigned long& count,
              const ::xml_schema::ro_string& ns,
              const ::xml_schema::ro_string& n,
              const ::xml_schema::ro_string* t,
              bool start)
  {
    XSD_UNUSED (t);

    switch (state)
    {
      case 0UL:
      {
        if (n == "song" &&
            ns == "http://subsonic.org/restapi")
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->song_parser_;

            if (this->song_parser_)
              this->song_parser_->pre ();
          }
          else
          {
            if (this->song_parser_)
            {
              this->song_parser_->post_Child ();
              this->song ();
            }

            count++;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = ~0UL;
          // Fall through.
        }
      }
      case ~0UL:
        break;
    }
  }

  // Element validation and dispatch functions for Videos_pskel.
  //
  bool Videos_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    if (vd->func == 0 && vd->state == 0)
    {
      if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
        return true;
      else
        vd->state = 1;
    }

    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, ns, n, t, true);

      vd = vs.data + (vs.size - 1);

      if (vd->state == ~0UL)
        vd = vs.data + (--vs.size - 1);
      else
        break;
    }

    if (vd->func == 0)
    {
      if (vd->state != ~0UL)
      {
        unsigned long s = ~0UL;

        if (n == "video" &&
            ns == "http://subsonic.org/restapi")
          s = 0UL;

        if (s != ~0UL)
        {
          vd->count++;
          vd->state = ~0UL;

          vd = vs.data + vs.size++;
          vd->func = &Videos_pskel::sequence_0;
          vd->state = s;
          vd->count = 0;

          this->sequence_0 (vd->state, vd->count, ns, n, t, true);
        }
        else
        {
          return false;
        }
      }
      else
        return false;
    }

    return true;
  }

  bool Videos_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size - 1];

    if (vd.func == 0 && vd.state == 0)
    {
      if (!::xml_schema::complex_content::_end_element_impl (ns, n))
        assert (false);
      return true;
    }

    assert (vd.func != 0);
    (this->*vd.func) (vd.state, vd.count, ns, n, 0, false);

    if (vd.state == ~0UL)
      vs.size--;

    return true;
  }

  void Videos_pskel::
  _pre_e_validate ()
  {
    this->v_state_stack_.push ();
    static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size++];

    vd.func = 0;
    vd.state = 0;
    vd.count = 0;
  }

  void Videos_pskel::
  _post_e_validate ()
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    ::xml_schema::ro_string empty;
    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, empty, empty, 0, true);
      assert (vd->state == ~0UL);
      vd = vs.data + (--vs.size - 1);
    }


    this->v_state_stack_.pop ();
  }

  void Videos_pskel::
  sequence_0 (unsigned long& state,
              unsigned long& count,
              const ::xml_schema::ro_string& ns,
              const ::xml_schema::ro_string& n,
              const ::xml_schema::ro_string* t,
              bool start)
  {
    XSD_UNUSED (t);

    switch (state)
    {
      case 0UL:
      {
        if (n == "video" &&
            ns == "http://subsonic.org/restapi")
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->video_parser_;

            if (this->video_parser_)
              this->video_parser_->pre ();
          }
          else
          {
            if (this->video_parser_)
            {
              this->video_parser_->post_Child ();
              this->video ();
            }

            count++;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = ~0UL;
          // Fall through.
        }
      }
      case ~0UL:
        break;
    }
  }

  // Element validation and dispatch functions for Directory_pskel.
  //
  bool Directory_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    if (vd->func == 0 && vd->state == 0)
    {
      if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
        return true;
      else
        vd->state = 1;
    }

    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, ns, n, t, true);

      vd = vs.data + (vs.size - 1);

      if (vd->state == ~0UL)
        vd = vs.data + (--vs.size - 1);
      else
        break;
    }

    if (vd->func == 0)
    {
      if (vd->state != ~0UL)
      {
        unsigned long s = ~0UL;

        if (n == "child" &&
            ns == "http://subsonic.org/restapi")
          s = 0UL;

        if (s != ~0UL)
        {
          vd->count++;
          vd->state = ~0UL;

          vd = vs.data + vs.size++;
          vd->func = &Directory_pskel::sequence_0;
          vd->state = s;
          vd->count = 0;

          this->sequence_0 (vd->state, vd->count, ns, n, t, true);
        }
        else
        {
          return false;
        }
      }
      else
        return false;
    }

    return true;
  }

  bool Directory_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size - 1];

    if (vd.func == 0 && vd.state == 0)
    {
      if (!::xml_schema::complex_content::_end_element_impl (ns, n))
        assert (false);
      return true;
    }

    assert (vd.func != 0);
    (this->*vd.func) (vd.state, vd.count, ns, n, 0, false);

    if (vd.state == ~0UL)
      vs.size--;

    return true;
  }

  void Directory_pskel::
  _pre_e_validate ()
  {
    this->v_state_stack_.push ();
    static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size++];

    vd.func = 0;
    vd.state = 0;
    vd.count = 0;
  }

  void Directory_pskel::
  _post_e_validate ()
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    ::xml_schema::ro_string empty;
    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, empty, empty, 0, true);
      assert (vd->state == ~0UL);
      vd = vs.data + (--vs.size - 1);
    }


    this->v_state_stack_.pop ();
  }

  void Directory_pskel::
  sequence_0 (unsigned long& state,
              unsigned long& count,
              const ::xml_schema::ro_string& ns,
              const ::xml_schema::ro_string& n,
              const ::xml_schema::ro_string* t,
              bool start)
  {
    XSD_UNUSED (t);

    switch (state)
    {
      case 0UL:
      {
        if (n == "child" &&
            ns == "http://subsonic.org/restapi")
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->child_parser_;

            if (this->child_parser_)
              this->child_parser_->pre ();
          }
          else
          {
            if (this->child_parser_)
            {
              this->child_parser_->post_Child ();
              this->child ();
            }

            count++;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = ~0UL;
          // Fall through.
        }
      }
      case ~0UL:
        break;
    }
  }

  // Element validation and dispatch functions for NowPlaying_pskel.
  //
  bool NowPlaying_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    if (vd->func == 0 && vd->state == 0)
    {
      if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
        return true;
      else
        vd->state = 1;
    }

    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, ns, n, t, true);

      vd = vs.data + (vs.size - 1);

      if (vd->state == ~0UL)
        vd = vs.data + (--vs.size - 1);
      else
        break;
    }

    if (vd->func == 0)
    {
      if (vd->state != ~0UL)
      {
        unsigned long s = ~0UL;

        if (n == "entry" &&
            ns == "http://subsonic.org/restapi")
          s = 0UL;

        if (s != ~0UL)
        {
          vd->count++;
          vd->state = ~0UL;

          vd = vs.data + vs.size++;
          vd->func = &NowPlaying_pskel::sequence_0;
          vd->state = s;
          vd->count = 0;

          this->sequence_0 (vd->state, vd->count, ns, n, t, true);
        }
        else
        {
          return false;
        }
      }
      else
        return false;
    }

    return true;
  }

  bool NowPlaying_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size - 1];

    if (vd.func == 0 && vd.state == 0)
    {
      if (!::xml_schema::complex_content::_end_element_impl (ns, n))
        assert (false);
      return true;
    }

    assert (vd.func != 0);
    (this->*vd.func) (vd.state, vd.count, ns, n, 0, false);

    if (vd.state == ~0UL)
      vs.size--;

    return true;
  }

  void NowPlaying_pskel::
  _pre_e_validate ()
  {
    this->v_state_stack_.push ();
    static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size++];

    vd.func = 0;
    vd.state = 0;
    vd.count = 0;
  }

  void NowPlaying_pskel::
  _post_e_validate ()
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    ::xml_schema::ro_string empty;
    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, empty, empty, 0, true);
      assert (vd->state == ~0UL);
      vd = vs.data + (--vs.size - 1);
    }


    this->v_state_stack_.pop ();
  }

  void NowPlaying_pskel::
  sequence_0 (unsigned long& state,
              unsigned long& count,
              const ::xml_schema::ro_string& ns,
              const ::xml_schema::ro_string& n,
              const ::xml_schema::ro_string* t,
              bool start)
  {
    XSD_UNUSED (t);

    switch (state)
    {
      case 0UL:
      {
        if (n == "entry" &&
            ns == "http://subsonic.org/restapi")
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->entry_parser_;

            if (this->entry_parser_)
              this->entry_parser_->pre ();
          }
          else
          {
            if (this->entry_parser_)
            {
              this->entry_parser_->post_NowPlayingEntry ();
              this->entry ();
            }

            count++;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = ~0UL;
          // Fall through.
        }
      }
      case ~0UL:
        break;
    }
  }

  // Element validation and dispatch functions for SearchResult_pskel.
  //
  bool SearchResult_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    if (vd->func == 0 && vd->state == 0)
    {
      if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
        return true;
      else
        vd->state = 1;
    }

    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, ns, n, t, true);

      vd = vs.data + (vs.size - 1);

      if (vd->state == ~0UL)
        vd = vs.data + (--vs.size - 1);
      else
        break;
    }

    if (vd->func == 0)
    {
      if (vd->state != ~0UL)
      {
        unsigned long s = ~0UL;

        if (n == "match" &&
            ns == "http://subsonic.org/restapi")
          s = 0UL;

        if (s != ~0UL)
        {
          vd->count++;
          vd->state = ~0UL;

          vd = vs.data + vs.size++;
          vd->func = &SearchResult_pskel::sequence_0;
          vd->state = s;
          vd->count = 0;

          this->sequence_0 (vd->state, vd->count, ns, n, t, true);
        }
        else
        {
          return false;
        }
      }
      else
        return false;
    }

    return true;
  }

  bool SearchResult_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size - 1];

    if (vd.func == 0 && vd.state == 0)
    {
      if (!::xml_schema::complex_content::_end_element_impl (ns, n))
        assert (false);
      return true;
    }

    assert (vd.func != 0);
    (this->*vd.func) (vd.state, vd.count, ns, n, 0, false);

    if (vd.state == ~0UL)
      vs.size--;

    return true;
  }

  void SearchResult_pskel::
  _pre_e_validate ()
  {
    this->v_state_stack_.push ();
    static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size++];

    vd.func = 0;
    vd.state = 0;
    vd.count = 0;
  }

  void SearchResult_pskel::
  _post_e_validate ()
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    ::xml_schema::ro_string empty;
    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, empty, empty, 0, true);
      assert (vd->state == ~0UL);
      vd = vs.data + (--vs.size - 1);
    }


    this->v_state_stack_.pop ();
  }

  void SearchResult_pskel::
  sequence_0 (unsigned long& state,
              unsigned long& count,
              const ::xml_schema::ro_string& ns,
              const ::xml_schema::ro_string& n,
              const ::xml_schema::ro_string* t,
              bool start)
  {
    XSD_UNUSED (t);

    switch (state)
    {
      case 0UL:
      {
        if (n == "match" &&
            ns == "http://subsonic.org/restapi")
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->match_parser_;

            if (this->match_parser_)
              this->match_parser_->pre ();
          }
          else
          {
            if (this->match_parser_)
            {
              this->match_parser_->post_Child ();
              this->match ();
            }

            count++;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = ~0UL;
          // Fall through.
        }
      }
      case ~0UL:
        break;
    }
  }

  // Element validation and dispatch functions for SearchResult2_pskel.
  //
  bool SearchResult2_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    if (vd->func == 0 && vd->state == 0)
    {
      if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
        return true;
      else
        vd->state = 1;
    }

    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, ns, n, t, true);

      vd = vs.data + (vs.size - 1);

      if (vd->state == ~0UL)
        vd = vs.data + (--vs.size - 1);
      else
        break;
    }

    if (vd->func == 0)
    {
      if (vd->state != ~0UL)
      {
        unsigned long s = ~0UL;

        if (n == "artist" &&
            ns == "http://subsonic.org/restapi")
          s = 0UL;
        else if (n == "album" &&
                 ns == "http://subsonic.org/restapi")
          s = 1UL;
        else if (n == "song" &&
                 ns == "http://subsonic.org/restapi")
          s = 2UL;

        if (s != ~0UL)
        {
          vd->count++;
          vd->state = ~0UL;

          vd = vs.data + vs.size++;
          vd->func = &SearchResult2_pskel::sequence_0;
          vd->state = s;
          vd->count = 0;

          this->sequence_0 (vd->state, vd->count, ns, n, t, true);
        }
        else
        {
          return false;
        }
      }
      else
        return false;
    }

    return true;
  }

  bool SearchResult2_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size - 1];

    if (vd.func == 0 && vd.state == 0)
    {
      if (!::xml_schema::complex_content::_end_element_impl (ns, n))
        assert (false);
      return true;
    }

    assert (vd.func != 0);
    (this->*vd.func) (vd.state, vd.count, ns, n, 0, false);

    if (vd.state == ~0UL)
      vs.size--;

    return true;
  }

  void SearchResult2_pskel::
  _pre_e_validate ()
  {
    this->v_state_stack_.push ();
    static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size++];

    vd.func = 0;
    vd.state = 0;
    vd.count = 0;
  }

  void SearchResult2_pskel::
  _post_e_validate ()
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    ::xml_schema::ro_string empty;
    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, empty, empty, 0, true);
      assert (vd->state == ~0UL);
      vd = vs.data + (--vs.size - 1);
    }


    this->v_state_stack_.pop ();
  }

  void SearchResult2_pskel::
  sequence_0 (unsigned long& state,
              unsigned long& count,
              const ::xml_schema::ro_string& ns,
              const ::xml_schema::ro_string& n,
              const ::xml_schema::ro_string* t,
              bool start)
  {
    XSD_UNUSED (t);

    switch (state)
    {
      case 0UL:
      {
        if (n == "artist" &&
            ns == "http://subsonic.org/restapi")
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->artist_parser_;

            if (this->artist_parser_)
              this->artist_parser_->pre ();
          }
          else
          {
            if (this->artist_parser_)
            {
              this->artist_parser_->post_Artist ();
              this->artist ();
            }

            count++;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 1UL;
          // Fall through.
        }
      }
      case 1UL:
      {
        if (n == "album" &&
            ns == "http://subsonic.org/restapi")
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->album_parser_;

            if (this->album_parser_)
              this->album_parser_->pre ();
          }
          else
          {
            if (this->album_parser_)
            {
              this->album_parser_->post_Child ();
              this->album ();
            }

            count++;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 2UL;
          // Fall through.
        }
      }
      case 2UL:
      {
        if (n == "song" &&
            ns == "http://subsonic.org/restapi")
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->song_parser_;

            if (this->song_parser_)
              this->song_parser_->pre ();
          }
          else
          {
            if (this->song_parser_)
            {
              this->song_parser_->post_Child ();
              this->song ();
            }

            count++;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = ~0UL;
          // Fall through.
        }
      }
      case ~0UL:
        break;
    }
  }

  // Element validation and dispatch functions for SearchResult3_pskel.
  //
  bool SearchResult3_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    if (vd->func == 0 && vd->state == 0)
    {
      if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
        return true;
      else
        vd->state = 1;
    }

    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, ns, n, t, true);

      vd = vs.data + (vs.size - 1);

      if (vd->state == ~0UL)
        vd = vs.data + (--vs.size - 1);
      else
        break;
    }

    if (vd->func == 0)
    {
      if (vd->state != ~0UL)
      {
        unsigned long s = ~0UL;

        if (n == "artist" &&
            ns == "http://subsonic.org/restapi")
          s = 0UL;
        else if (n == "album" &&
                 ns == "http://subsonic.org/restapi")
          s = 1UL;
        else if (n == "song" &&
                 ns == "http://subsonic.org/restapi")
          s = 2UL;

        if (s != ~0UL)
        {
          vd->count++;
          vd->state = ~0UL;

          vd = vs.data + vs.size++;
          vd->func = &SearchResult3_pskel::sequence_0;
          vd->state = s;
          vd->count = 0;

          this->sequence_0 (vd->state, vd->count, ns, n, t, true);
        }
        else
        {
          return false;
        }
      }
      else
        return false;
    }

    return true;
  }

  bool SearchResult3_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size - 1];

    if (vd.func == 0 && vd.state == 0)
    {
      if (!::xml_schema::complex_content::_end_element_impl (ns, n))
        assert (false);
      return true;
    }

    assert (vd.func != 0);
    (this->*vd.func) (vd.state, vd.count, ns, n, 0, false);

    if (vd.state == ~0UL)
      vs.size--;

    return true;
  }

  void SearchResult3_pskel::
  _pre_e_validate ()
  {
    this->v_state_stack_.push ();
    static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size++];

    vd.func = 0;
    vd.state = 0;
    vd.count = 0;
  }

  void SearchResult3_pskel::
  _post_e_validate ()
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    ::xml_schema::ro_string empty;
    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, empty, empty, 0, true);
      assert (vd->state == ~0UL);
      vd = vs.data + (--vs.size - 1);
    }


    this->v_state_stack_.pop ();
  }

  void SearchResult3_pskel::
  sequence_0 (unsigned long& state,
              unsigned long& count,
              const ::xml_schema::ro_string& ns,
              const ::xml_schema::ro_string& n,
              const ::xml_schema::ro_string* t,
              bool start)
  {
    XSD_UNUSED (t);

    switch (state)
    {
      case 0UL:
      {
        if (n == "artist" &&
            ns == "http://subsonic.org/restapi")
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->artist_parser_;

            if (this->artist_parser_)
              this->artist_parser_->pre ();
          }
          else
          {
            if (this->artist_parser_)
            {
              this->artist_parser_->post_ArtistID3 ();
              this->artist ();
            }

            count++;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 1UL;
          // Fall through.
        }
      }
      case 1UL:
      {
        if (n == "album" &&
            ns == "http://subsonic.org/restapi")
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->album_parser_;

            if (this->album_parser_)
              this->album_parser_->pre ();
          }
          else
          {
            if (this->album_parser_)
            {
              this->album_parser_->post_AlbumID3 ();
              this->album ();
            }

            count++;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 2UL;
          // Fall through.
        }
      }
      case 2UL:
      {
        if (n == "song" &&
            ns == "http://subsonic.org/restapi")
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->song_parser_;

            if (this->song_parser_)
              this->song_parser_->pre ();
          }
          else
          {
            if (this->song_parser_)
            {
              this->song_parser_->post_Child ();
              this->song ();
            }

            count++;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = ~0UL;
          // Fall through.
        }
      }
      case ~0UL:
        break;
    }
  }

  // Element validation and dispatch functions for Playlists_pskel.
  //
  bool Playlists_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    if (vd->func == 0 && vd->state == 0)
    {
      if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
        return true;
      else
        vd->state = 1;
    }

    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, ns, n, t, true);

      vd = vs.data + (vs.size - 1);

      if (vd->state == ~0UL)
        vd = vs.data + (--vs.size - 1);
      else
        break;
    }

    if (vd->func == 0)
    {
      if (vd->state != ~0UL)
      {
        unsigned long s = ~0UL;

        if (n == "playlist" &&
            ns == "http://subsonic.org/restapi")
          s = 0UL;

        if (s != ~0UL)
        {
          vd->count++;
          vd->state = ~0UL;

          vd = vs.data + vs.size++;
          vd->func = &Playlists_pskel::sequence_0;
          vd->state = s;
          vd->count = 0;

          this->sequence_0 (vd->state, vd->count, ns, n, t, true);
        }
        else
        {
          return false;
        }
      }
      else
        return false;
    }

    return true;
  }

  bool Playlists_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size - 1];

    if (vd.func == 0 && vd.state == 0)
    {
      if (!::xml_schema::complex_content::_end_element_impl (ns, n))
        assert (false);
      return true;
    }

    assert (vd.func != 0);
    (this->*vd.func) (vd.state, vd.count, ns, n, 0, false);

    if (vd.state == ~0UL)
      vs.size--;

    return true;
  }

  void Playlists_pskel::
  _pre_e_validate ()
  {
    this->v_state_stack_.push ();
    static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size++];

    vd.func = 0;
    vd.state = 0;
    vd.count = 0;
  }

  void Playlists_pskel::
  _post_e_validate ()
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    ::xml_schema::ro_string empty;
    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, empty, empty, 0, true);
      assert (vd->state == ~0UL);
      vd = vs.data + (--vs.size - 1);
    }


    this->v_state_stack_.pop ();
  }

  void Playlists_pskel::
  sequence_0 (unsigned long& state,
              unsigned long& count,
              const ::xml_schema::ro_string& ns,
              const ::xml_schema::ro_string& n,
              const ::xml_schema::ro_string* t,
              bool start)
  {
    XSD_UNUSED (t);

    switch (state)
    {
      case 0UL:
      {
        if (n == "playlist" &&
            ns == "http://subsonic.org/restapi")
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->playlist_parser_;

            if (this->playlist_parser_)
              this->playlist_parser_->pre ();
          }
          else
          {
            if (this->playlist_parser_)
            {
              this->playlist_parser_->post_Playlist ();
              this->playlist ();
            }

            count++;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = ~0UL;
          // Fall through.
        }
      }
      case ~0UL:
        break;
    }
  }

  // Element validation and dispatch functions for Playlist_pskel.
  //
  bool Playlist_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    if (vd->func == 0 && vd->state == 0)
    {
      if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
        return true;
      else
        vd->state = 1;
    }

    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, ns, n, t, true);

      vd = vs.data + (vs.size - 1);

      if (vd->state == ~0UL)
        vd = vs.data + (--vs.size - 1);
      else
        break;
    }

    if (vd->func == 0)
    {
      if (vd->state != ~0UL)
      {
        unsigned long s = ~0UL;

        if (n == "allowedUser" &&
            ns == "http://subsonic.org/restapi")
          s = 0UL;

        if (s != ~0UL)
        {
          vd->count++;
          vd->state = ~0UL;

          vd = vs.data + vs.size++;
          vd->func = &Playlist_pskel::sequence_0;
          vd->state = s;
          vd->count = 0;

          this->sequence_0 (vd->state, vd->count, ns, n, t, true);
        }
        else
        {
          return false;
        }
      }
      else
        return false;
    }

    return true;
  }

  bool Playlist_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size - 1];

    if (vd.func == 0 && vd.state == 0)
    {
      if (!::xml_schema::complex_content::_end_element_impl (ns, n))
        assert (false);
      return true;
    }

    assert (vd.func != 0);
    (this->*vd.func) (vd.state, vd.count, ns, n, 0, false);

    if (vd.state == ~0UL)
      vs.size--;

    return true;
  }

  void Playlist_pskel::
  _pre_e_validate ()
  {
    this->v_state_stack_.push ();
    static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size++];

    vd.func = 0;
    vd.state = 0;
    vd.count = 0;
  }

  void Playlist_pskel::
  _post_e_validate ()
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    ::xml_schema::ro_string empty;
    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, empty, empty, 0, true);
      assert (vd->state == ~0UL);
      vd = vs.data + (--vs.size - 1);
    }


    this->v_state_stack_.pop ();
  }

  void Playlist_pskel::
  sequence_0 (unsigned long& state,
              unsigned long& count,
              const ::xml_schema::ro_string& ns,
              const ::xml_schema::ro_string& n,
              const ::xml_schema::ro_string* t,
              bool start)
  {
    XSD_UNUSED (t);

    switch (state)
    {
      case 0UL:
      {
        if (n == "allowedUser" &&
            ns == "http://subsonic.org/restapi")
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->allowedUser_parser_;

            if (this->allowedUser_parser_)
              this->allowedUser_parser_->pre ();
          }
          else
          {
            if (this->allowedUser_parser_)
            {
              const ::std::string& tmp (this->allowedUser_parser_->post_string ());
              this->allowedUser (tmp);
            }

            count++;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = ~0UL;
          // Fall through.
        }
      }
      case ~0UL:
        break;
    }
  }

  // Element validation and dispatch functions for PlaylistWithSongs_pskel.
  //
  bool PlaylistWithSongs_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    if (vd->func == 0 && vd->state == 0)
    {
      if (this->::restapi::Playlist_pskel::_start_element_impl (ns, n, t))
        return true;
      else
        vd->state = 1;
    }

    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, ns, n, t, true);

      vd = vs.data + (vs.size - 1);

      if (vd->state == ~0UL)
        vd = vs.data + (--vs.size - 1);
      else
        break;
    }

    if (vd->func == 0)
    {
      if (vd->state != ~0UL)
      {
        unsigned long s = ~0UL;

        if (n == "entry" &&
            ns == "http://subsonic.org/restapi")
          s = 0UL;

        if (s != ~0UL)
        {
          vd->count++;
          vd->state = ~0UL;

          vd = vs.data + vs.size++;
          vd->func = &PlaylistWithSongs_pskel::sequence_0;
          vd->state = s;
          vd->count = 0;

          this->sequence_0 (vd->state, vd->count, ns, n, t, true);
        }
        else
        {
          return false;
        }
      }
      else
        return false;
    }

    return true;
  }

  bool PlaylistWithSongs_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size - 1];

    if (vd.func == 0 && vd.state == 0)
    {
      if (!::restapi::Playlist_pskel::_end_element_impl (ns, n))
        assert (false);
      return true;
    }

    assert (vd.func != 0);
    (this->*vd.func) (vd.state, vd.count, ns, n, 0, false);

    if (vd.state == ~0UL)
      vs.size--;

    return true;
  }

  void PlaylistWithSongs_pskel::
  _pre_e_validate ()
  {
    this->v_state_stack_.push ();
    static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size++];

    vd.func = 0;
    vd.state = 0;
    vd.count = 0;

    ::restapi::Playlist_pskel::_pre_e_validate ();
  }

  void PlaylistWithSongs_pskel::
  _post_e_validate ()
  {
    ::restapi::Playlist_pskel::_post_e_validate ();

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    ::xml_schema::ro_string empty;
    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, empty, empty, 0, true);
      assert (vd->state == ~0UL);
      vd = vs.data + (--vs.size - 1);
    }


    this->v_state_stack_.pop ();
  }

  void PlaylistWithSongs_pskel::
  sequence_0 (unsigned long& state,
              unsigned long& count,
              const ::xml_schema::ro_string& ns,
              const ::xml_schema::ro_string& n,
              const ::xml_schema::ro_string* t,
              bool start)
  {
    XSD_UNUSED (t);

    switch (state)
    {
      case 0UL:
      {
        if (n == "entry" &&
            ns == "http://subsonic.org/restapi")
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->entry_parser_;

            if (this->entry_parser_)
              this->entry_parser_->pre ();
          }
          else
          {
            if (this->entry_parser_)
            {
              this->entry_parser_->post_Child ();
              this->entry ();
            }

            count++;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = ~0UL;
          // Fall through.
        }
      }
      case ~0UL:
        break;
    }
  }

  // Element validation and dispatch functions for JukeboxPlaylist_pskel.
  //
  bool JukeboxPlaylist_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    if (vd->func == 0 && vd->state == 0)
    {
      if (this->::restapi::JukeboxStatus_pskel::_start_element_impl (ns, n, t))
        return true;
      else
        vd->state = 1;
    }

    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, ns, n, t, true);

      vd = vs.data + (vs.size - 1);

      if (vd->state == ~0UL)
        vd = vs.data + (--vs.size - 1);
      else
        break;
    }

    if (vd->func == 0)
    {
      if (vd->state != ~0UL)
      {
        unsigned long s = ~0UL;

        if (n == "entry" &&
            ns == "http://subsonic.org/restapi")
          s = 0UL;

        if (s != ~0UL)
        {
          vd->count++;
          vd->state = ~0UL;

          vd = vs.data + vs.size++;
          vd->func = &JukeboxPlaylist_pskel::sequence_0;
          vd->state = s;
          vd->count = 0;

          this->sequence_0 (vd->state, vd->count, ns, n, t, true);
        }
        else
        {
          return false;
        }
      }
      else
        return false;
    }

    return true;
  }

  bool JukeboxPlaylist_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size - 1];

    if (vd.func == 0 && vd.state == 0)
    {
      if (!::restapi::JukeboxStatus_pskel::_end_element_impl (ns, n))
        assert (false);
      return true;
    }

    assert (vd.func != 0);
    (this->*vd.func) (vd.state, vd.count, ns, n, 0, false);

    if (vd.state == ~0UL)
      vs.size--;

    return true;
  }

  void JukeboxPlaylist_pskel::
  _pre_e_validate ()
  {
    this->v_state_stack_.push ();
    static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size++];

    vd.func = 0;
    vd.state = 0;
    vd.count = 0;

    ::restapi::JukeboxStatus_pskel::_pre_e_validate ();
  }

  void JukeboxPlaylist_pskel::
  _post_e_validate ()
  {
    ::restapi::JukeboxStatus_pskel::_post_e_validate ();

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    ::xml_schema::ro_string empty;
    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, empty, empty, 0, true);
      assert (vd->state == ~0UL);
      vd = vs.data + (--vs.size - 1);
    }


    this->v_state_stack_.pop ();
  }

  void JukeboxPlaylist_pskel::
  sequence_0 (unsigned long& state,
              unsigned long& count,
              const ::xml_schema::ro_string& ns,
              const ::xml_schema::ro_string& n,
              const ::xml_schema::ro_string* t,
              bool start)
  {
    XSD_UNUSED (t);

    switch (state)
    {
      case 0UL:
      {
        if (n == "entry" &&
            ns == "http://subsonic.org/restapi")
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->entry_parser_;

            if (this->entry_parser_)
              this->entry_parser_->pre ();
          }
          else
          {
            if (this->entry_parser_)
            {
              this->entry_parser_->post_Child ();
              this->entry ();
            }

            count++;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = ~0UL;
          // Fall through.
        }
      }
      case ~0UL:
        break;
    }
  }

  // Element validation and dispatch functions for ChatMessages_pskel.
  //
  bool ChatMessages_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    if (vd->func == 0 && vd->state == 0)
    {
      if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
        return true;
      else
        vd->state = 1;
    }

    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, ns, n, t, true);

      vd = vs.data + (vs.size - 1);

      if (vd->state == ~0UL)
        vd = vs.data + (--vs.size - 1);
      else
        break;
    }

    if (vd->func == 0)
    {
      if (vd->state != ~0UL)
      {
        unsigned long s = ~0UL;

        if (n == "chatMessage" &&
            ns == "http://subsonic.org/restapi")
          s = 0UL;

        if (s != ~0UL)
        {
          vd->count++;
          vd->state = ~0UL;

          vd = vs.data + vs.size++;
          vd->func = &ChatMessages_pskel::sequence_0;
          vd->state = s;
          vd->count = 0;

          this->sequence_0 (vd->state, vd->count, ns, n, t, true);
        }
        else
        {
          return false;
        }
      }
      else
        return false;
    }

    return true;
  }

  bool ChatMessages_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size - 1];

    if (vd.func == 0 && vd.state == 0)
    {
      if (!::xml_schema::complex_content::_end_element_impl (ns, n))
        assert (false);
      return true;
    }

    assert (vd.func != 0);
    (this->*vd.func) (vd.state, vd.count, ns, n, 0, false);

    if (vd.state == ~0UL)
      vs.size--;

    return true;
  }

  void ChatMessages_pskel::
  _pre_e_validate ()
  {
    this->v_state_stack_.push ();
    static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size++];

    vd.func = 0;
    vd.state = 0;
    vd.count = 0;
  }

  void ChatMessages_pskel::
  _post_e_validate ()
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    ::xml_schema::ro_string empty;
    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, empty, empty, 0, true);
      assert (vd->state == ~0UL);
      vd = vs.data + (--vs.size - 1);
    }


    this->v_state_stack_.pop ();
  }

  void ChatMessages_pskel::
  sequence_0 (unsigned long& state,
              unsigned long& count,
              const ::xml_schema::ro_string& ns,
              const ::xml_schema::ro_string& n,
              const ::xml_schema::ro_string* t,
              bool start)
  {
    XSD_UNUSED (t);

    switch (state)
    {
      case 0UL:
      {
        if (n == "chatMessage" &&
            ns == "http://subsonic.org/restapi")
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->chatMessage_parser_;

            if (this->chatMessage_parser_)
              this->chatMessage_parser_->pre ();
          }
          else
          {
            if (this->chatMessage_parser_)
            {
              this->chatMessage_parser_->post_ChatMessage ();
              this->chatMessage ();
            }

            count++;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = ~0UL;
          // Fall through.
        }
      }
      case ~0UL:
        break;
    }
  }

  // Element validation and dispatch functions for AlbumList_pskel.
  //
  bool AlbumList_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    if (vd->func == 0 && vd->state == 0)
    {
      if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
        return true;
      else
        vd->state = 1;
    }

    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, ns, n, t, true);

      vd = vs.data + (vs.size - 1);

      if (vd->state == ~0UL)
        vd = vs.data + (--vs.size - 1);
      else
        break;
    }

    if (vd->func == 0)
    {
      if (vd->state != ~0UL)
      {
        unsigned long s = ~0UL;

        if (n == "album" &&
            ns == "http://subsonic.org/restapi")
          s = 0UL;

        if (s != ~0UL)
        {
          vd->count++;
          vd->state = ~0UL;

          vd = vs.data + vs.size++;
          vd->func = &AlbumList_pskel::sequence_0;
          vd->state = s;
          vd->count = 0;

          this->sequence_0 (vd->state, vd->count, ns, n, t, true);
        }
        else
        {
          return false;
        }
      }
      else
        return false;
    }

    return true;
  }

  bool AlbumList_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size - 1];

    if (vd.func == 0 && vd.state == 0)
    {
      if (!::xml_schema::complex_content::_end_element_impl (ns, n))
        assert (false);
      return true;
    }

    assert (vd.func != 0);
    (this->*vd.func) (vd.state, vd.count, ns, n, 0, false);

    if (vd.state == ~0UL)
      vs.size--;

    return true;
  }

  void AlbumList_pskel::
  _pre_e_validate ()
  {
    this->v_state_stack_.push ();
    static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size++];

    vd.func = 0;
    vd.state = 0;
    vd.count = 0;
  }

  void AlbumList_pskel::
  _post_e_validate ()
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    ::xml_schema::ro_string empty;
    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, empty, empty, 0, true);
      assert (vd->state == ~0UL);
      vd = vs.data + (--vs.size - 1);
    }


    this->v_state_stack_.pop ();
  }

  void AlbumList_pskel::
  sequence_0 (unsigned long& state,
              unsigned long& count,
              const ::xml_schema::ro_string& ns,
              const ::xml_schema::ro_string& n,
              const ::xml_schema::ro_string* t,
              bool start)
  {
    XSD_UNUSED (t);

    switch (state)
    {
      case 0UL:
      {
        if (n == "album" &&
            ns == "http://subsonic.org/restapi")
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->album_parser_;

            if (this->album_parser_)
              this->album_parser_->pre ();
          }
          else
          {
            if (this->album_parser_)
            {
              this->album_parser_->post_Child ();
              this->album ();
            }

            count++;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = ~0UL;
          // Fall through.
        }
      }
      case ~0UL:
        break;
    }
  }

  // Element validation and dispatch functions for AlbumList2_pskel.
  //
  bool AlbumList2_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    if (vd->func == 0 && vd->state == 0)
    {
      if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
        return true;
      else
        vd->state = 1;
    }

    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, ns, n, t, true);

      vd = vs.data + (vs.size - 1);

      if (vd->state == ~0UL)
        vd = vs.data + (--vs.size - 1);
      else
        break;
    }

    if (vd->func == 0)
    {
      if (vd->state != ~0UL)
      {
        unsigned long s = ~0UL;

        if (n == "album" &&
            ns == "http://subsonic.org/restapi")
          s = 0UL;

        if (s != ~0UL)
        {
          vd->count++;
          vd->state = ~0UL;

          vd = vs.data + vs.size++;
          vd->func = &AlbumList2_pskel::sequence_0;
          vd->state = s;
          vd->count = 0;

          this->sequence_0 (vd->state, vd->count, ns, n, t, true);
        }
        else
        {
          return false;
        }
      }
      else
        return false;
    }

    return true;
  }

  bool AlbumList2_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size - 1];

    if (vd.func == 0 && vd.state == 0)
    {
      if (!::xml_schema::complex_content::_end_element_impl (ns, n))
        assert (false);
      return true;
    }

    assert (vd.func != 0);
    (this->*vd.func) (vd.state, vd.count, ns, n, 0, false);

    if (vd.state == ~0UL)
      vs.size--;

    return true;
  }

  void AlbumList2_pskel::
  _pre_e_validate ()
  {
    this->v_state_stack_.push ();
    static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size++];

    vd.func = 0;
    vd.state = 0;
    vd.count = 0;
  }

  void AlbumList2_pskel::
  _post_e_validate ()
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    ::xml_schema::ro_string empty;
    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, empty, empty, 0, true);
      assert (vd->state == ~0UL);
      vd = vs.data + (--vs.size - 1);
    }


    this->v_state_stack_.pop ();
  }

  void AlbumList2_pskel::
  sequence_0 (unsigned long& state,
              unsigned long& count,
              const ::xml_schema::ro_string& ns,
              const ::xml_schema::ro_string& n,
              const ::xml_schema::ro_string* t,
              bool start)
  {
    XSD_UNUSED (t);

    switch (state)
    {
      case 0UL:
      {
        if (n == "album" &&
            ns == "http://subsonic.org/restapi")
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->album_parser_;

            if (this->album_parser_)
              this->album_parser_->pre ();
          }
          else
          {
            if (this->album_parser_)
            {
              this->album_parser_->post_AlbumID3 ();
              this->album ();
            }

            count++;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = ~0UL;
          // Fall through.
        }
      }
      case ~0UL:
        break;
    }
  }

  // Element validation and dispatch functions for Songs_pskel.
  //
  bool Songs_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    if (vd->func == 0 && vd->state == 0)
    {
      if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
        return true;
      else
        vd->state = 1;
    }

    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, ns, n, t, true);

      vd = vs.data + (vs.size - 1);

      if (vd->state == ~0UL)
        vd = vs.data + (--vs.size - 1);
      else
        break;
    }

    if (vd->func == 0)
    {
      if (vd->state != ~0UL)
      {
        unsigned long s = ~0UL;

        if (n == "song" &&
            ns == "http://subsonic.org/restapi")
          s = 0UL;

        if (s != ~0UL)
        {
          vd->count++;
          vd->state = ~0UL;

          vd = vs.data + vs.size++;
          vd->func = &Songs_pskel::sequence_0;
          vd->state = s;
          vd->count = 0;

          this->sequence_0 (vd->state, vd->count, ns, n, t, true);
        }
        else
        {
          return false;
        }
      }
      else
        return false;
    }

    return true;
  }

  bool Songs_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size - 1];

    if (vd.func == 0 && vd.state == 0)
    {
      if (!::xml_schema::complex_content::_end_element_impl (ns, n))
        assert (false);
      return true;
    }

    assert (vd.func != 0);
    (this->*vd.func) (vd.state, vd.count, ns, n, 0, false);

    if (vd.state == ~0UL)
      vs.size--;

    return true;
  }

  void Songs_pskel::
  _pre_e_validate ()
  {
    this->v_state_stack_.push ();
    static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size++];

    vd.func = 0;
    vd.state = 0;
    vd.count = 0;
  }

  void Songs_pskel::
  _post_e_validate ()
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    ::xml_schema::ro_string empty;
    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, empty, empty, 0, true);
      assert (vd->state == ~0UL);
      vd = vs.data + (--vs.size - 1);
    }


    this->v_state_stack_.pop ();
  }

  void Songs_pskel::
  sequence_0 (unsigned long& state,
              unsigned long& count,
              const ::xml_schema::ro_string& ns,
              const ::xml_schema::ro_string& n,
              const ::xml_schema::ro_string* t,
              bool start)
  {
    XSD_UNUSED (t);

    switch (state)
    {
      case 0UL:
      {
        if (n == "song" &&
            ns == "http://subsonic.org/restapi")
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->song_parser_;

            if (this->song_parser_)
              this->song_parser_->pre ();
          }
          else
          {
            if (this->song_parser_)
            {
              this->song_parser_->post_Child ();
              this->song ();
            }

            count++;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = ~0UL;
          // Fall through.
        }
      }
      case ~0UL:
        break;
    }
  }

  // Element validation and dispatch functions for Podcasts_pskel.
  //
  bool Podcasts_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    if (vd->func == 0 && vd->state == 0)
    {
      if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
        return true;
      else
        vd->state = 1;
    }

    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, ns, n, t, true);

      vd = vs.data + (vs.size - 1);

      if (vd->state == ~0UL)
        vd = vs.data + (--vs.size - 1);
      else
        break;
    }

    if (vd->func == 0)
    {
      if (vd->state != ~0UL)
      {
        unsigned long s = ~0UL;

        if (n == "channel" &&
            ns == "http://subsonic.org/restapi")
          s = 0UL;

        if (s != ~0UL)
        {
          vd->count++;
          vd->state = ~0UL;

          vd = vs.data + vs.size++;
          vd->func = &Podcasts_pskel::sequence_0;
          vd->state = s;
          vd->count = 0;

          this->sequence_0 (vd->state, vd->count, ns, n, t, true);
        }
        else
        {
          return false;
        }
      }
      else
        return false;
    }

    return true;
  }

  bool Podcasts_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size - 1];

    if (vd.func == 0 && vd.state == 0)
    {
      if (!::xml_schema::complex_content::_end_element_impl (ns, n))
        assert (false);
      return true;
    }

    assert (vd.func != 0);
    (this->*vd.func) (vd.state, vd.count, ns, n, 0, false);

    if (vd.state == ~0UL)
      vs.size--;

    return true;
  }

  void Podcasts_pskel::
  _pre_e_validate ()
  {
    this->v_state_stack_.push ();
    static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size++];

    vd.func = 0;
    vd.state = 0;
    vd.count = 0;
  }

  void Podcasts_pskel::
  _post_e_validate ()
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    ::xml_schema::ro_string empty;
    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, empty, empty, 0, true);
      assert (vd->state == ~0UL);
      vd = vs.data + (--vs.size - 1);
    }


    this->v_state_stack_.pop ();
  }

  void Podcasts_pskel::
  sequence_0 (unsigned long& state,
              unsigned long& count,
              const ::xml_schema::ro_string& ns,
              const ::xml_schema::ro_string& n,
              const ::xml_schema::ro_string* t,
              bool start)
  {
    XSD_UNUSED (t);

    switch (state)
    {
      case 0UL:
      {
        if (n == "channel" &&
            ns == "http://subsonic.org/restapi")
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->channel_parser_;

            if (this->channel_parser_)
              this->channel_parser_->pre ();
          }
          else
          {
            if (this->channel_parser_)
            {
              this->channel_parser_->post_PodcastChannel ();
              this->channel ();
            }

            count++;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = ~0UL;
          // Fall through.
        }
      }
      case ~0UL:
        break;
    }
  }

  // Element validation and dispatch functions for PodcastChannel_pskel.
  //
  bool PodcastChannel_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    if (vd->func == 0 && vd->state == 0)
    {
      if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
        return true;
      else
        vd->state = 1;
    }

    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, ns, n, t, true);

      vd = vs.data + (vs.size - 1);

      if (vd->state == ~0UL)
        vd = vs.data + (--vs.size - 1);
      else
        break;
    }

    if (vd->func == 0)
    {
      if (vd->state != ~0UL)
      {
        unsigned long s = ~0UL;

        if (n == "episode" &&
            ns == "http://subsonic.org/restapi")
          s = 0UL;

        if (s != ~0UL)
        {
          vd->count++;
          vd->state = ~0UL;

          vd = vs.data + vs.size++;
          vd->func = &PodcastChannel_pskel::sequence_0;
          vd->state = s;
          vd->count = 0;

          this->sequence_0 (vd->state, vd->count, ns, n, t, true);
        }
        else
        {
          return false;
        }
      }
      else
        return false;
    }

    return true;
  }

  bool PodcastChannel_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size - 1];

    if (vd.func == 0 && vd.state == 0)
    {
      if (!::xml_schema::complex_content::_end_element_impl (ns, n))
        assert (false);
      return true;
    }

    assert (vd.func != 0);
    (this->*vd.func) (vd.state, vd.count, ns, n, 0, false);

    if (vd.state == ~0UL)
      vs.size--;

    return true;
  }

  void PodcastChannel_pskel::
  _pre_e_validate ()
  {
    this->v_state_stack_.push ();
    static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size++];

    vd.func = 0;
    vd.state = 0;
    vd.count = 0;
  }

  void PodcastChannel_pskel::
  _post_e_validate ()
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    ::xml_schema::ro_string empty;
    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, empty, empty, 0, true);
      assert (vd->state == ~0UL);
      vd = vs.data + (--vs.size - 1);
    }


    this->v_state_stack_.pop ();
  }

  void PodcastChannel_pskel::
  sequence_0 (unsigned long& state,
              unsigned long& count,
              const ::xml_schema::ro_string& ns,
              const ::xml_schema::ro_string& n,
              const ::xml_schema::ro_string* t,
              bool start)
  {
    XSD_UNUSED (t);

    switch (state)
    {
      case 0UL:
      {
        if (n == "episode" &&
            ns == "http://subsonic.org/restapi")
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->episode_parser_;

            if (this->episode_parser_)
              this->episode_parser_->pre ();
          }
          else
          {
            if (this->episode_parser_)
            {
              this->episode_parser_->post_PodcastEpisode ();
              this->episode ();
            }

            count++;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = ~0UL;
          // Fall through.
        }
      }
      case ~0UL:
        break;
    }
  }

  // Element validation and dispatch functions for InternetRadioStations_pskel.
  //
  bool InternetRadioStations_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    if (vd->func == 0 && vd->state == 0)
    {
      if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
        return true;
      else
        vd->state = 1;
    }

    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, ns, n, t, true);

      vd = vs.data + (vs.size - 1);

      if (vd->state == ~0UL)
        vd = vs.data + (--vs.size - 1);
      else
        break;
    }

    if (vd->func == 0)
    {
      if (vd->state != ~0UL)
      {
        unsigned long s = ~0UL;

        if (n == "internetRadioStation" &&
            ns == "http://subsonic.org/restapi")
          s = 0UL;

        if (s != ~0UL)
        {
          vd->count++;
          vd->state = ~0UL;

          vd = vs.data + vs.size++;
          vd->func = &InternetRadioStations_pskel::sequence_0;
          vd->state = s;
          vd->count = 0;

          this->sequence_0 (vd->state, vd->count, ns, n, t, true);
        }
        else
        {
          return false;
        }
      }
      else
        return false;
    }

    return true;
  }

  bool InternetRadioStations_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size - 1];

    if (vd.func == 0 && vd.state == 0)
    {
      if (!::xml_schema::complex_content::_end_element_impl (ns, n))
        assert (false);
      return true;
    }

    assert (vd.func != 0);
    (this->*vd.func) (vd.state, vd.count, ns, n, 0, false);

    if (vd.state == ~0UL)
      vs.size--;

    return true;
  }

  void InternetRadioStations_pskel::
  _pre_e_validate ()
  {
    this->v_state_stack_.push ();
    static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size++];

    vd.func = 0;
    vd.state = 0;
    vd.count = 0;
  }

  void InternetRadioStations_pskel::
  _post_e_validate ()
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    ::xml_schema::ro_string empty;
    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, empty, empty, 0, true);
      assert (vd->state == ~0UL);
      vd = vs.data + (--vs.size - 1);
    }


    this->v_state_stack_.pop ();
  }

  void InternetRadioStations_pskel::
  sequence_0 (unsigned long& state,
              unsigned long& count,
              const ::xml_schema::ro_string& ns,
              const ::xml_schema::ro_string& n,
              const ::xml_schema::ro_string* t,
              bool start)
  {
    XSD_UNUSED (t);

    switch (state)
    {
      case 0UL:
      {
        if (n == "internetRadioStation" &&
            ns == "http://subsonic.org/restapi")
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->internetRadioStation_parser_;

            if (this->internetRadioStation_parser_)
              this->internetRadioStation_parser_->pre ();
          }
          else
          {
            if (this->internetRadioStation_parser_)
            {
              this->internetRadioStation_parser_->post_InternetRadioStation ();
              this->internetRadioStation ();
            }

            count++;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = ~0UL;
          // Fall through.
        }
      }
      case ~0UL:
        break;
    }
  }

  // Element validation and dispatch functions for Bookmarks_pskel.
  //
  bool Bookmarks_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    if (vd->func == 0 && vd->state == 0)
    {
      if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
        return true;
      else
        vd->state = 1;
    }

    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, ns, n, t, true);

      vd = vs.data + (vs.size - 1);

      if (vd->state == ~0UL)
        vd = vs.data + (--vs.size - 1);
      else
        break;
    }

    if (vd->func == 0)
    {
      if (vd->state != ~0UL)
      {
        unsigned long s = ~0UL;

        if (n == "bookmark" &&
            ns == "http://subsonic.org/restapi")
          s = 0UL;

        if (s != ~0UL)
        {
          vd->count++;
          vd->state = ~0UL;

          vd = vs.data + vs.size++;
          vd->func = &Bookmarks_pskel::sequence_0;
          vd->state = s;
          vd->count = 0;

          this->sequence_0 (vd->state, vd->count, ns, n, t, true);
        }
        else
        {
          return false;
        }
      }
      else
        return false;
    }

    return true;
  }

  bool Bookmarks_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size - 1];

    if (vd.func == 0 && vd.state == 0)
    {
      if (!::xml_schema::complex_content::_end_element_impl (ns, n))
        assert (false);
      return true;
    }

    assert (vd.func != 0);
    (this->*vd.func) (vd.state, vd.count, ns, n, 0, false);

    if (vd.state == ~0UL)
      vs.size--;

    return true;
  }

  void Bookmarks_pskel::
  _pre_e_validate ()
  {
    this->v_state_stack_.push ();
    static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size++];

    vd.func = 0;
    vd.state = 0;
    vd.count = 0;
  }

  void Bookmarks_pskel::
  _post_e_validate ()
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    ::xml_schema::ro_string empty;
    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, empty, empty, 0, true);
      assert (vd->state == ~0UL);
      vd = vs.data + (--vs.size - 1);
    }


    this->v_state_stack_.pop ();
  }

  void Bookmarks_pskel::
  sequence_0 (unsigned long& state,
              unsigned long& count,
              const ::xml_schema::ro_string& ns,
              const ::xml_schema::ro_string& n,
              const ::xml_schema::ro_string* t,
              bool start)
  {
    XSD_UNUSED (t);

    switch (state)
    {
      case 0UL:
      {
        if (n == "bookmark" &&
            ns == "http://subsonic.org/restapi")
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->bookmark_parser_;

            if (this->bookmark_parser_)
              this->bookmark_parser_->pre ();
          }
          else
          {
            if (this->bookmark_parser_)
            {
              this->bookmark_parser_->post_Bookmark ();
              this->bookmark ();
            }

            count++;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = ~0UL;
          // Fall through.
        }
      }
      case ~0UL:
        break;
    }
  }

  // Element validation and dispatch functions for Bookmark_pskel.
  //
  bool Bookmark_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    if (vd->func == 0 && vd->state == 0)
    {
      if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
        return true;
      else
        vd->state = 1;
    }

    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, ns, n, t, true);

      vd = vs.data + (vs.size - 1);

      if (vd->state == ~0UL)
        vd = vs.data + (--vs.size - 1);
      else
        break;
    }

    if (vd->func == 0)
    {
      if (vd->state != ~0UL)
      {
        unsigned long s = ~0UL;

        if (n == "entry" &&
            ns == "http://subsonic.org/restapi")
          s = 0UL;

        if (s != ~0UL)
        {
          vd->count++;
          vd->state = ~0UL;

          vd = vs.data + vs.size++;
          vd->func = &Bookmark_pskel::sequence_0;
          vd->state = s;
          vd->count = 0;

          this->sequence_0 (vd->state, vd->count, ns, n, t, true);
        }
        else
        {
          if (vd->count < 1UL)
            this->_expected_element (
              "http://subsonic.org/restapi", "entry",
              ns, n);
          return false;
        }
      }
      else
        return false;
    }

    return true;
  }

  bool Bookmark_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size - 1];

    if (vd.func == 0 && vd.state == 0)
    {
      if (!::xml_schema::complex_content::_end_element_impl (ns, n))
        assert (false);
      return true;
    }

    assert (vd.func != 0);
    (this->*vd.func) (vd.state, vd.count, ns, n, 0, false);

    if (vd.state == ~0UL)
      vs.size--;

    return true;
  }

  void Bookmark_pskel::
  _pre_e_validate ()
  {
    this->v_state_stack_.push ();
    static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size++];

    vd.func = 0;
    vd.state = 0;
    vd.count = 0;
  }

  void Bookmark_pskel::
  _post_e_validate ()
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    ::xml_schema::ro_string empty;
    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, empty, empty, 0, true);
      assert (vd->state == ~0UL);
      vd = vs.data + (--vs.size - 1);
    }

    if (vd->count < 1UL)
      this->_expected_element (
        "http://subsonic.org/restapi", "entry");

    this->v_state_stack_.pop ();
  }

  void Bookmark_pskel::
  sequence_0 (unsigned long& state,
              unsigned long& count,
              const ::xml_schema::ro_string& ns,
              const ::xml_schema::ro_string& n,
              const ::xml_schema::ro_string* t,
              bool start)
  {
    XSD_UNUSED (t);

    switch (state)
    {
      case 0UL:
      {
        if (n == "entry" &&
            ns == "http://subsonic.org/restapi")
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->entry_parser_;

            if (this->entry_parser_)
              this->entry_parser_->pre ();
          }
          else
          {
            if (this->entry_parser_)
            {
              this->entry_parser_->post_Child ();
              this->entry ();
            }

            count = 0;
            state = ~0UL;
          }

          break;
        }
        else
        {
          assert (start);
          if (count < 1UL)
            this->_expected_element (
              "http://subsonic.org/restapi", "entry",
              ns, n);
          count = 0;
          state = ~0UL;
          // Fall through.
        }
      }
      case ~0UL:
        break;
    }
  }

  // Element validation and dispatch functions for Shares_pskel.
  //
  bool Shares_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    if (vd->func == 0 && vd->state == 0)
    {
      if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
        return true;
      else
        vd->state = 1;
    }

    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, ns, n, t, true);

      vd = vs.data + (vs.size - 1);

      if (vd->state == ~0UL)
        vd = vs.data + (--vs.size - 1);
      else
        break;
    }

    if (vd->func == 0)
    {
      if (vd->state != ~0UL)
      {
        unsigned long s = ~0UL;

        if (n == "share" &&
            ns == "http://subsonic.org/restapi")
          s = 0UL;

        if (s != ~0UL)
        {
          vd->count++;
          vd->state = ~0UL;

          vd = vs.data + vs.size++;
          vd->func = &Shares_pskel::sequence_0;
          vd->state = s;
          vd->count = 0;

          this->sequence_0 (vd->state, vd->count, ns, n, t, true);
        }
        else
        {
          return false;
        }
      }
      else
        return false;
    }

    return true;
  }

  bool Shares_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size - 1];

    if (vd.func == 0 && vd.state == 0)
    {
      if (!::xml_schema::complex_content::_end_element_impl (ns, n))
        assert (false);
      return true;
    }

    assert (vd.func != 0);
    (this->*vd.func) (vd.state, vd.count, ns, n, 0, false);

    if (vd.state == ~0UL)
      vs.size--;

    return true;
  }

  void Shares_pskel::
  _pre_e_validate ()
  {
    this->v_state_stack_.push ();
    static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size++];

    vd.func = 0;
    vd.state = 0;
    vd.count = 0;
  }

  void Shares_pskel::
  _post_e_validate ()
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    ::xml_schema::ro_string empty;
    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, empty, empty, 0, true);
      assert (vd->state == ~0UL);
      vd = vs.data + (--vs.size - 1);
    }


    this->v_state_stack_.pop ();
  }

  void Shares_pskel::
  sequence_0 (unsigned long& state,
              unsigned long& count,
              const ::xml_schema::ro_string& ns,
              const ::xml_schema::ro_string& n,
              const ::xml_schema::ro_string* t,
              bool start)
  {
    XSD_UNUSED (t);

    switch (state)
    {
      case 0UL:
      {
        if (n == "share" &&
            ns == "http://subsonic.org/restapi")
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->share_parser_;

            if (this->share_parser_)
              this->share_parser_->pre ();
          }
          else
          {
            if (this->share_parser_)
            {
              this->share_parser_->post_Share ();
              this->share ();
            }

            count++;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = ~0UL;
          // Fall through.
        }
      }
      case ~0UL:
        break;
    }
  }

  // Element validation and dispatch functions for Share_pskel.
  //
  bool Share_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    if (vd->func == 0 && vd->state == 0)
    {
      if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
        return true;
      else
        vd->state = 1;
    }

    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, ns, n, t, true);

      vd = vs.data + (vs.size - 1);

      if (vd->state == ~0UL)
        vd = vs.data + (--vs.size - 1);
      else
        break;
    }

    if (vd->func == 0)
    {
      if (vd->state != ~0UL)
      {
        unsigned long s = ~0UL;

        if (n == "entry" &&
            ns == "http://subsonic.org/restapi")
          s = 0UL;

        if (s != ~0UL)
        {
          vd->count++;
          vd->state = ~0UL;

          vd = vs.data + vs.size++;
          vd->func = &Share_pskel::sequence_0;
          vd->state = s;
          vd->count = 0;

          this->sequence_0 (vd->state, vd->count, ns, n, t, true);
        }
        else
        {
          return false;
        }
      }
      else
        return false;
    }

    return true;
  }

  bool Share_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size - 1];

    if (vd.func == 0 && vd.state == 0)
    {
      if (!::xml_schema::complex_content::_end_element_impl (ns, n))
        assert (false);
      return true;
    }

    assert (vd.func != 0);
    (this->*vd.func) (vd.state, vd.count, ns, n, 0, false);

    if (vd.state == ~0UL)
      vs.size--;

    return true;
  }

  void Share_pskel::
  _pre_e_validate ()
  {
    this->v_state_stack_.push ();
    static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size++];

    vd.func = 0;
    vd.state = 0;
    vd.count = 0;
  }

  void Share_pskel::
  _post_e_validate ()
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    ::xml_schema::ro_string empty;
    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, empty, empty, 0, true);
      assert (vd->state == ~0UL);
      vd = vs.data + (--vs.size - 1);
    }


    this->v_state_stack_.pop ();
  }

  void Share_pskel::
  sequence_0 (unsigned long& state,
              unsigned long& count,
              const ::xml_schema::ro_string& ns,
              const ::xml_schema::ro_string& n,
              const ::xml_schema::ro_string* t,
              bool start)
  {
    XSD_UNUSED (t);

    switch (state)
    {
      case 0UL:
      {
        if (n == "entry" &&
            ns == "http://subsonic.org/restapi")
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->entry_parser_;

            if (this->entry_parser_)
              this->entry_parser_->pre ();
          }
          else
          {
            if (this->entry_parser_)
            {
              this->entry_parser_->post_Child ();
              this->entry ();
            }

            count++;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = ~0UL;
          // Fall through.
        }
      }
      case ~0UL:
        break;
    }
  }

  // Element validation and dispatch functions for Starred_pskel.
  //
  bool Starred_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    if (vd->func == 0 && vd->state == 0)
    {
      if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
        return true;
      else
        vd->state = 1;
    }

    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, ns, n, t, true);

      vd = vs.data + (vs.size - 1);

      if (vd->state == ~0UL)
        vd = vs.data + (--vs.size - 1);
      else
        break;
    }

    if (vd->func == 0)
    {
      if (vd->state != ~0UL)
      {
        unsigned long s = ~0UL;

        if (n == "artist" &&
            ns == "http://subsonic.org/restapi")
          s = 0UL;
        else if (n == "album" &&
                 ns == "http://subsonic.org/restapi")
          s = 1UL;
        else if (n == "song" &&
                 ns == "http://subsonic.org/restapi")
          s = 2UL;

        if (s != ~0UL)
        {
          vd->count++;
          vd->state = ~0UL;

          vd = vs.data + vs.size++;
          vd->func = &Starred_pskel::sequence_0;
          vd->state = s;
          vd->count = 0;

          this->sequence_0 (vd->state, vd->count, ns, n, t, true);
        }
        else
        {
          return false;
        }
      }
      else
        return false;
    }

    return true;
  }

  bool Starred_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size - 1];

    if (vd.func == 0 && vd.state == 0)
    {
      if (!::xml_schema::complex_content::_end_element_impl (ns, n))
        assert (false);
      return true;
    }

    assert (vd.func != 0);
    (this->*vd.func) (vd.state, vd.count, ns, n, 0, false);

    if (vd.state == ~0UL)
      vs.size--;

    return true;
  }

  void Starred_pskel::
  _pre_e_validate ()
  {
    this->v_state_stack_.push ();
    static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size++];

    vd.func = 0;
    vd.state = 0;
    vd.count = 0;
  }

  void Starred_pskel::
  _post_e_validate ()
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    ::xml_schema::ro_string empty;
    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, empty, empty, 0, true);
      assert (vd->state == ~0UL);
      vd = vs.data + (--vs.size - 1);
    }


    this->v_state_stack_.pop ();
  }

  void Starred_pskel::
  sequence_0 (unsigned long& state,
              unsigned long& count,
              const ::xml_schema::ro_string& ns,
              const ::xml_schema::ro_string& n,
              const ::xml_schema::ro_string* t,
              bool start)
  {
    XSD_UNUSED (t);

    switch (state)
    {
      case 0UL:
      {
        if (n == "artist" &&
            ns == "http://subsonic.org/restapi")
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->artist_parser_;

            if (this->artist_parser_)
              this->artist_parser_->pre ();
          }
          else
          {
            if (this->artist_parser_)
            {
              this->artist_parser_->post_Artist ();
              this->artist ();
            }

            count++;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 1UL;
          // Fall through.
        }
      }
      case 1UL:
      {
        if (n == "album" &&
            ns == "http://subsonic.org/restapi")
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->album_parser_;

            if (this->album_parser_)
              this->album_parser_->pre ();
          }
          else
          {
            if (this->album_parser_)
            {
              this->album_parser_->post_Child ();
              this->album ();
            }

            count++;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 2UL;
          // Fall through.
        }
      }
      case 2UL:
      {
        if (n == "song" &&
            ns == "http://subsonic.org/restapi")
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->song_parser_;

            if (this->song_parser_)
              this->song_parser_->pre ();
          }
          else
          {
            if (this->song_parser_)
            {
              this->song_parser_->post_Child ();
              this->song ();
            }

            count++;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = ~0UL;
          // Fall through.
        }
      }
      case ~0UL:
        break;
    }
  }

  // Element validation and dispatch functions for Starred2_pskel.
  //
  bool Starred2_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    if (vd->func == 0 && vd->state == 0)
    {
      if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
        return true;
      else
        vd->state = 1;
    }

    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, ns, n, t, true);

      vd = vs.data + (vs.size - 1);

      if (vd->state == ~0UL)
        vd = vs.data + (--vs.size - 1);
      else
        break;
    }

    if (vd->func == 0)
    {
      if (vd->state != ~0UL)
      {
        unsigned long s = ~0UL;

        if (n == "artist" &&
            ns == "http://subsonic.org/restapi")
          s = 0UL;
        else if (n == "album" &&
                 ns == "http://subsonic.org/restapi")
          s = 1UL;
        else if (n == "song" &&
                 ns == "http://subsonic.org/restapi")
          s = 2UL;

        if (s != ~0UL)
        {
          vd->count++;
          vd->state = ~0UL;

          vd = vs.data + vs.size++;
          vd->func = &Starred2_pskel::sequence_0;
          vd->state = s;
          vd->count = 0;

          this->sequence_0 (vd->state, vd->count, ns, n, t, true);
        }
        else
        {
          return false;
        }
      }
      else
        return false;
    }

    return true;
  }

  bool Starred2_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size - 1];

    if (vd.func == 0 && vd.state == 0)
    {
      if (!::xml_schema::complex_content::_end_element_impl (ns, n))
        assert (false);
      return true;
    }

    assert (vd.func != 0);
    (this->*vd.func) (vd.state, vd.count, ns, n, 0, false);

    if (vd.state == ~0UL)
      vs.size--;

    return true;
  }

  void Starred2_pskel::
  _pre_e_validate ()
  {
    this->v_state_stack_.push ();
    static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size++];

    vd.func = 0;
    vd.state = 0;
    vd.count = 0;
  }

  void Starred2_pskel::
  _post_e_validate ()
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    ::xml_schema::ro_string empty;
    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, empty, empty, 0, true);
      assert (vd->state == ~0UL);
      vd = vs.data + (--vs.size - 1);
    }


    this->v_state_stack_.pop ();
  }

  void Starred2_pskel::
  sequence_0 (unsigned long& state,
              unsigned long& count,
              const ::xml_schema::ro_string& ns,
              const ::xml_schema::ro_string& n,
              const ::xml_schema::ro_string* t,
              bool start)
  {
    XSD_UNUSED (t);

    switch (state)
    {
      case 0UL:
      {
        if (n == "artist" &&
            ns == "http://subsonic.org/restapi")
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->artist_parser_;

            if (this->artist_parser_)
              this->artist_parser_->pre ();
          }
          else
          {
            if (this->artist_parser_)
            {
              this->artist_parser_->post_ArtistID3 ();
              this->artist ();
            }

            count++;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 1UL;
          // Fall through.
        }
      }
      case 1UL:
      {
        if (n == "album" &&
            ns == "http://subsonic.org/restapi")
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->album_parser_;

            if (this->album_parser_)
              this->album_parser_->pre ();
          }
          else
          {
            if (this->album_parser_)
            {
              this->album_parser_->post_AlbumID3 ();
              this->album ();
            }

            count++;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 2UL;
          // Fall through.
        }
      }
      case 2UL:
      {
        if (n == "song" &&
            ns == "http://subsonic.org/restapi")
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->song_parser_;

            if (this->song_parser_)
              this->song_parser_->pre ();
          }
          else
          {
            if (this->song_parser_)
            {
              this->song_parser_->post_Child ();
              this->song ();
            }

            count++;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = ~0UL;
          // Fall through.
        }
      }
      case ~0UL:
        break;
    }
  }

  // Element validation and dispatch functions for Users_pskel.
  //
  bool Users_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    if (vd->func == 0 && vd->state == 0)
    {
      if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
        return true;
      else
        vd->state = 1;
    }

    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, ns, n, t, true);

      vd = vs.data + (vs.size - 1);

      if (vd->state == ~0UL)
        vd = vs.data + (--vs.size - 1);
      else
        break;
    }

    if (vd->func == 0)
    {
      if (vd->state != ~0UL)
      {
        unsigned long s = ~0UL;

        if (n == "user" &&
            ns == "http://subsonic.org/restapi")
          s = 0UL;

        if (s != ~0UL)
        {
          vd->count++;
          vd->state = ~0UL;

          vd = vs.data + vs.size++;
          vd->func = &Users_pskel::sequence_0;
          vd->state = s;
          vd->count = 0;

          this->sequence_0 (vd->state, vd->count, ns, n, t, true);
        }
        else
        {
          return false;
        }
      }
      else
        return false;
    }

    return true;
  }

  bool Users_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size - 1];

    if (vd.func == 0 && vd.state == 0)
    {
      if (!::xml_schema::complex_content::_end_element_impl (ns, n))
        assert (false);
      return true;
    }

    assert (vd.func != 0);
    (this->*vd.func) (vd.state, vd.count, ns, n, 0, false);

    if (vd.state == ~0UL)
      vs.size--;

    return true;
  }

  void Users_pskel::
  _pre_e_validate ()
  {
    this->v_state_stack_.push ();
    static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size++];

    vd.func = 0;
    vd.state = 0;
    vd.count = 0;
  }

  void Users_pskel::
  _post_e_validate ()
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    ::xml_schema::ro_string empty;
    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, empty, empty, 0, true);
      assert (vd->state == ~0UL);
      vd = vs.data + (--vs.size - 1);
    }


    this->v_state_stack_.pop ();
  }

  void Users_pskel::
  sequence_0 (unsigned long& state,
              unsigned long& count,
              const ::xml_schema::ro_string& ns,
              const ::xml_schema::ro_string& n,
              const ::xml_schema::ro_string* t,
              bool start)
  {
    XSD_UNUSED (t);

    switch (state)
    {
      case 0UL:
      {
        if (n == "user" &&
            ns == "http://subsonic.org/restapi")
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->user_parser_;

            if (this->user_parser_)
              this->user_parser_->pre ();
          }
          else
          {
            if (this->user_parser_)
            {
              this->user_parser_->post_User ();
              this->user ();
            }

            count++;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = ~0UL;
          // Fall through.
        }
      }
      case ~0UL:
        break;
    }
  }
}

namespace restapi
{
  // Attribute validation and dispatch functions for Response_pskel.
  //
  bool Response_pskel::
  _attribute_impl_phase_one (const ::xml_schema::ro_string& ns,
                             const ::xml_schema::ro_string& n,
                             const ::xml_schema::ro_string& s)
  {
    if (n == "status" && ns.empty ())
    {
      if (this->status_parser_)
      {
        this->status_parser_->pre ();
        this->status_parser_->_pre_impl ();
        this->status_parser_->_characters (s);
        this->status_parser_->_post_impl ();
        this->status_parser_->post_ResponseStatus ();
        this->status ();
      }

      static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ())->status = true;
      return true;
    }

    if (n == "version" && ns.empty ())
    {
      if (this->version_parser_)
      {
        this->version_parser_->pre ();
        this->version_parser_->_pre_impl ();
        this->version_parser_->_characters (s);
        this->version_parser_->_post_impl ();
        this->version_parser_->post_Version ();
        this->version ();
      }

      static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ())->version = true;
      return true;
    }

    return false;
  }

  void Response_pskel::
  _pre_a_validate ()
  {
    this->v_state_attr_stack_.push ();
    v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());

    as.status = false;
    as.version = false;
  }

  void Response_pskel::
  _post_a_validate ()
  {
    v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());

    if (!as.status)
      this->_expected_attribute (
        "", "status");
    if (!as.version)
      this->_expected_attribute (
        "", "version");

    this->v_state_attr_stack_.pop ();
  }

  // Attribute validation and dispatch functions for MusicFolder_pskel.
  //
  bool MusicFolder_pskel::
  _attribute_impl_phase_one (const ::xml_schema::ro_string& ns,
                             const ::xml_schema::ro_string& n,
                             const ::xml_schema::ro_string& s)
  {
    if (n == "id" && ns.empty ())
    {
      if (this->id_parser_)
      {
        this->id_parser_->pre ();
        this->id_parser_->_pre_impl ();
        this->id_parser_->_characters (s);
        this->id_parser_->_post_impl ();
        int tmp (this->id_parser_->post_int ());
        this->id (tmp);
      }

      static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ())->id = true;
      return true;
    }

    if (n == "name" && ns.empty ())
    {
      if (this->name_parser_)
      {
        this->name_parser_->pre ();
        this->name_parser_->_pre_impl ();
        this->name_parser_->_characters (s);
        this->name_parser_->_post_impl ();
        const ::std::string& tmp (this->name_parser_->post_string ());
        this->name (tmp);
      }

      return true;
    }

    return false;
  }

  void MusicFolder_pskel::
  _pre_a_validate ()
  {
    this->v_state_attr_stack_.push ();
    v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());

    as.id = false;
  }

  void MusicFolder_pskel::
  _post_a_validate ()
  {
    v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());

    if (!as.id)
      this->_expected_attribute (
        "", "id");

    this->v_state_attr_stack_.pop ();
  }

  // Attribute validation and dispatch functions for Indexes_pskel.
  //
  bool Indexes_pskel::
  _attribute_impl_phase_one (const ::xml_schema::ro_string& ns,
                             const ::xml_schema::ro_string& n,
                             const ::xml_schema::ro_string& s)
  {
    if (n == "lastModified" && ns.empty ())
    {
      if (this->lastModified_parser_)
      {
        this->lastModified_parser_->pre ();
        this->lastModified_parser_->_pre_impl ();
        this->lastModified_parser_->_characters (s);
        this->lastModified_parser_->_post_impl ();
        long long tmp (this->lastModified_parser_->post_long ());
        this->lastModified (tmp);
      }

      static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ())->lastModified = true;
      return true;
    }

    if (n == "ignoredArticles" && ns.empty ())
    {
      if (this->ignoredArticles_parser_)
      {
        this->ignoredArticles_parser_->pre ();
        this->ignoredArticles_parser_->_pre_impl ();
        this->ignoredArticles_parser_->_characters (s);
        this->ignoredArticles_parser_->_post_impl ();
        const ::std::string& tmp (this->ignoredArticles_parser_->post_string ());
        this->ignoredArticles (tmp);
      }

      static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ())->ignoredArticles = true;
      return true;
    }

    return false;
  }

  void Indexes_pskel::
  _pre_a_validate ()
  {
    this->v_state_attr_stack_.push ();
    v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());

    as.lastModified = false;
    as.ignoredArticles = false;
  }

  void Indexes_pskel::
  _post_a_validate ()
  {
    v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());

    if (!as.lastModified)
      this->_expected_attribute (
        "", "lastModified");
    if (!as.ignoredArticles)
      this->_expected_attribute (
        "", "ignoredArticles");

    this->v_state_attr_stack_.pop ();
  }

  // Attribute validation and dispatch functions for Index_pskel.
  //
  bool Index_pskel::
  _attribute_impl_phase_one (const ::xml_schema::ro_string& ns,
                             const ::xml_schema::ro_string& n,
                             const ::xml_schema::ro_string& s)
  {
    if (n == "name" && ns.empty ())
    {
      if (this->name_parser_)
      {
        this->name_parser_->pre ();
        this->name_parser_->_pre_impl ();
        this->name_parser_->_characters (s);
        this->name_parser_->_post_impl ();
        const ::std::string& tmp (this->name_parser_->post_string ());
        this->name (tmp);
      }

      static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ())->name = true;
      return true;
    }

    return false;
  }

  void Index_pskel::
  _pre_a_validate ()
  {
    this->v_state_attr_stack_.push ();
    v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());

    as.name = false;
  }

  void Index_pskel::
  _post_a_validate ()
  {
    v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());

    if (!as.name)
      this->_expected_attribute (
        "", "name");

    this->v_state_attr_stack_.pop ();
  }

  // Attribute validation and dispatch functions for Artist_pskel.
  //
  bool Artist_pskel::
  _attribute_impl_phase_one (const ::xml_schema::ro_string& ns,
                             const ::xml_schema::ro_string& n,
                             const ::xml_schema::ro_string& s)
  {
    if (n == "id" && ns.empty ())
    {
      if (this->id_parser_)
      {
        this->id_parser_->pre ();
        this->id_parser_->_pre_impl ();
        this->id_parser_->_characters (s);
        this->id_parser_->_post_impl ();
        const ::std::string& tmp (this->id_parser_->post_string ());
        this->id (tmp);
      }

      static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ())->id = true;
      return true;
    }

    if (n == "name" && ns.empty ())
    {
      if (this->name_parser_)
      {
        this->name_parser_->pre ();
        this->name_parser_->_pre_impl ();
        this->name_parser_->_characters (s);
        this->name_parser_->_post_impl ();
        const ::std::string& tmp (this->name_parser_->post_string ());
        this->name (tmp);
      }

      static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ())->name = true;
      return true;
    }

    if (n == "starred" && ns.empty ())
    {
      if (this->starred_parser_)
      {
        this->starred_parser_->pre ();
        this->starred_parser_->_pre_impl ();
        this->starred_parser_->_characters (s);
        this->starred_parser_->_post_impl ();
        const ::xml_schema::date_time& tmp (this->starred_parser_->post_date_time ());
        this->starred (tmp);
      }

      return true;
    }

    return false;
  }

  void Artist_pskel::
  _pre_a_validate ()
  {
    this->v_state_attr_stack_.push ();
    v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());

    as.id = false;
    as.name = false;
  }

  void Artist_pskel::
  _post_a_validate ()
  {
    v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());

    if (!as.id)
      this->_expected_attribute (
        "", "id");
    if (!as.name)
      this->_expected_attribute (
        "", "name");

    this->v_state_attr_stack_.pop ();
  }

  // Attribute validation and dispatch functions for Genre_pskel.
  //
  bool Genre_pskel::
  _attribute_impl_phase_one (const ::xml_schema::ro_string& ns,
                             const ::xml_schema::ro_string& n,
                             const ::xml_schema::ro_string& s)
  {
    if (n == "songCount" && ns.empty ())
    {
      if (this->songCount_parser_)
      {
        this->songCount_parser_->pre ();
        this->songCount_parser_->_pre_impl ();
        this->songCount_parser_->_characters (s);
        this->songCount_parser_->_post_impl ();
        int tmp (this->songCount_parser_->post_int ());
        this->songCount (tmp);
      }

      static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ())->songCount = true;
      return true;
    }

    if (n == "albumCount" && ns.empty ())
    {
      if (this->albumCount_parser_)
      {
        this->albumCount_parser_->pre ();
        this->albumCount_parser_->_pre_impl ();
        this->albumCount_parser_->_characters (s);
        this->albumCount_parser_->_post_impl ();
        int tmp (this->albumCount_parser_->post_int ());
        this->albumCount (tmp);
      }

      static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ())->albumCount = true;
      return true;
    }

    return false;
  }

  void Genre_pskel::
  _pre_a_validate ()
  {
    this->v_state_attr_stack_.push ();
    v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());

    as.songCount = false;
    as.albumCount = false;
  }

  void Genre_pskel::
  _post_a_validate ()
  {
    v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());

    if (!as.songCount)
      this->_expected_attribute (
        "", "songCount");
    if (!as.albumCount)
      this->_expected_attribute (
        "", "albumCount");

    this->v_state_attr_stack_.pop ();
  }

  // Attribute validation and dispatch functions for ArtistsID3_pskel.
  //
  bool ArtistsID3_pskel::
  _attribute_impl_phase_one (const ::xml_schema::ro_string& ns,
                             const ::xml_schema::ro_string& n,
                             const ::xml_schema::ro_string& s)
  {
    if (n == "ignoredArticles" && ns.empty ())
    {
      if (this->ignoredArticles_parser_)
      {
        this->ignoredArticles_parser_->pre ();
        this->ignoredArticles_parser_->_pre_impl ();
        this->ignoredArticles_parser_->_characters (s);
        this->ignoredArticles_parser_->_post_impl ();
        const ::std::string& tmp (this->ignoredArticles_parser_->post_string ());
        this->ignoredArticles (tmp);
      }

      static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ())->ignoredArticles = true;
      return true;
    }

    return false;
  }

  void ArtistsID3_pskel::
  _pre_a_validate ()
  {
    this->v_state_attr_stack_.push ();
    v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());

    as.ignoredArticles = false;
  }

  void ArtistsID3_pskel::
  _post_a_validate ()
  {
    v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());

    if (!as.ignoredArticles)
      this->_expected_attribute (
        "", "ignoredArticles");

    this->v_state_attr_stack_.pop ();
  }

  // Attribute validation and dispatch functions for IndexID3_pskel.
  //
  bool IndexID3_pskel::
  _attribute_impl_phase_one (const ::xml_schema::ro_string& ns,
                             const ::xml_schema::ro_string& n,
                             const ::xml_schema::ro_string& s)
  {
    if (n == "name" && ns.empty ())
    {
      if (this->name_parser_)
      {
        this->name_parser_->pre ();
        this->name_parser_->_pre_impl ();
        this->name_parser_->_characters (s);
        this->name_parser_->_post_impl ();
        const ::std::string& tmp (this->name_parser_->post_string ());
        this->name (tmp);
      }

      static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ())->name = true;
      return true;
    }

    return false;
  }

  void IndexID3_pskel::
  _pre_a_validate ()
  {
    this->v_state_attr_stack_.push ();
    v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());

    as.name = false;
  }

  void IndexID3_pskel::
  _post_a_validate ()
  {
    v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());

    if (!as.name)
      this->_expected_attribute (
        "", "name");

    this->v_state_attr_stack_.pop ();
  }

  // Attribute validation and dispatch functions for ArtistID3_pskel.
  //
  bool ArtistID3_pskel::
  _attribute_impl_phase_one (const ::xml_schema::ro_string& ns,
                             const ::xml_schema::ro_string& n,
                             const ::xml_schema::ro_string& s)
  {
    if (n == "id" && ns.empty ())
    {
      if (this->id_parser_)
      {
        this->id_parser_->pre ();
        this->id_parser_->_pre_impl ();
        this->id_parser_->_characters (s);
        this->id_parser_->_post_impl ();
        const ::std::string& tmp (this->id_parser_->post_string ());
        this->id (tmp);
      }

      static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ())->id = true;
      return true;
    }

    if (n == "name" && ns.empty ())
    {
      if (this->name_parser_)
      {
        this->name_parser_->pre ();
        this->name_parser_->_pre_impl ();
        this->name_parser_->_characters (s);
        this->name_parser_->_post_impl ();
        const ::std::string& tmp (this->name_parser_->post_string ());
        this->name (tmp);
      }

      static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ())->name = true;
      return true;
    }

    if (n == "coverArt" && ns.empty ())
    {
      if (this->coverArt_parser_)
      {
        this->coverArt_parser_->pre ();
        this->coverArt_parser_->_pre_impl ();
        this->coverArt_parser_->_characters (s);
        this->coverArt_parser_->_post_impl ();
        const ::std::string& tmp (this->coverArt_parser_->post_string ());
        this->coverArt (tmp);
      }

      return true;
    }

    if (n == "albumCount" && ns.empty ())
    {
      if (this->albumCount_parser_)
      {
        this->albumCount_parser_->pre ();
        this->albumCount_parser_->_pre_impl ();
        this->albumCount_parser_->_characters (s);
        this->albumCount_parser_->_post_impl ();
        int tmp (this->albumCount_parser_->post_int ());
        this->albumCount (tmp);
      }

      static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ())->albumCount = true;
      return true;
    }

    if (n == "starred" && ns.empty ())
    {
      if (this->starred_parser_)
      {
        this->starred_parser_->pre ();
        this->starred_parser_->_pre_impl ();
        this->starred_parser_->_characters (s);
        this->starred_parser_->_post_impl ();
        const ::xml_schema::date_time& tmp (this->starred_parser_->post_date_time ());
        this->starred (tmp);
      }

      return true;
    }

    return false;
  }

  void ArtistID3_pskel::
  _pre_a_validate ()
  {
    this->v_state_attr_stack_.push ();
    v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());

    as.id = false;
    as.name = false;
    as.albumCount = false;
  }

  void ArtistID3_pskel::
  _post_a_validate ()
  {
    v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());

    if (!as.id)
      this->_expected_attribute (
        "", "id");
    if (!as.name)
      this->_expected_attribute (
        "", "name");
    if (!as.albumCount)
      this->_expected_attribute (
        "", "albumCount");

    this->v_state_attr_stack_.pop ();
  }

  // Attribute validation and dispatch functions for AlbumID3_pskel.
  //
  bool AlbumID3_pskel::
  _attribute_impl_phase_one (const ::xml_schema::ro_string& ns,
                             const ::xml_schema::ro_string& n,
                             const ::xml_schema::ro_string& s)
  {
    if (n == "id" && ns.empty ())
    {
      if (this->id_parser_)
      {
        this->id_parser_->pre ();
        this->id_parser_->_pre_impl ();
        this->id_parser_->_characters (s);
        this->id_parser_->_post_impl ();
        const ::std::string& tmp (this->id_parser_->post_string ());
        this->id (tmp);
      }

      static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ())->id = true;
      return true;
    }

    if (n == "name" && ns.empty ())
    {
      if (this->name_parser_)
      {
        this->name_parser_->pre ();
        this->name_parser_->_pre_impl ();
        this->name_parser_->_characters (s);
        this->name_parser_->_post_impl ();
        const ::std::string& tmp (this->name_parser_->post_string ());
        this->name (tmp);
      }

      static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ())->name = true;
      return true;
    }

    if (n == "artist" && ns.empty ())
    {
      if (this->artist_parser_)
      {
        this->artist_parser_->pre ();
        this->artist_parser_->_pre_impl ();
        this->artist_parser_->_characters (s);
        this->artist_parser_->_post_impl ();
        const ::std::string& tmp (this->artist_parser_->post_string ());
        this->artist (tmp);
      }

      return true;
    }

    if (n == "artistId" && ns.empty ())
    {
      if (this->artistId_parser_)
      {
        this->artistId_parser_->pre ();
        this->artistId_parser_->_pre_impl ();
        this->artistId_parser_->_characters (s);
        this->artistId_parser_->_post_impl ();
        const ::std::string& tmp (this->artistId_parser_->post_string ());
        this->artistId (tmp);
      }

      return true;
    }

    if (n == "coverArt" && ns.empty ())
    {
      if (this->coverArt_parser_)
      {
        this->coverArt_parser_->pre ();
        this->coverArt_parser_->_pre_impl ();
        this->coverArt_parser_->_characters (s);
        this->coverArt_parser_->_post_impl ();
        const ::std::string& tmp (this->coverArt_parser_->post_string ());
        this->coverArt (tmp);
      }

      return true;
    }

    if (n == "songCount" && ns.empty ())
    {
      if (this->songCount_parser_)
      {
        this->songCount_parser_->pre ();
        this->songCount_parser_->_pre_impl ();
        this->songCount_parser_->_characters (s);
        this->songCount_parser_->_post_impl ();
        int tmp (this->songCount_parser_->post_int ());
        this->songCount (tmp);
      }

      static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ())->songCount = true;
      return true;
    }

    if (n == "duration" && ns.empty ())
    {
      if (this->duration_parser_)
      {
        this->duration_parser_->pre ();
        this->duration_parser_->_pre_impl ();
        this->duration_parser_->_characters (s);
        this->duration_parser_->_post_impl ();
        int tmp (this->duration_parser_->post_int ());
        this->duration (tmp);
      }

      static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ())->duration = true;
      return true;
    }

    if (n == "created" && ns.empty ())
    {
      if (this->created_parser_)
      {
        this->created_parser_->pre ();
        this->created_parser_->_pre_impl ();
        this->created_parser_->_characters (s);
        this->created_parser_->_post_impl ();
        const ::xml_schema::date_time& tmp (this->created_parser_->post_date_time ());
        this->created (tmp);
      }

      static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ())->created = true;
      return true;
    }

    if (n == "starred" && ns.empty ())
    {
      if (this->starred_parser_)
      {
        this->starred_parser_->pre ();
        this->starred_parser_->_pre_impl ();
        this->starred_parser_->_characters (s);
        this->starred_parser_->_post_impl ();
        const ::xml_schema::date_time& tmp (this->starred_parser_->post_date_time ());
        this->starred (tmp);
      }

      return true;
    }

    if (n == "year" && ns.empty ())
    {
      if (this->year_parser_)
      {
        this->year_parser_->pre ();
        this->year_parser_->_pre_impl ();
        this->year_parser_->_characters (s);
        this->year_parser_->_post_impl ();
        int tmp (this->year_parser_->post_int ());
        this->year (tmp);
      }

      return true;
    }

    if (n == "genre" && ns.empty ())
    {
      if (this->genre_parser_)
      {
        this->genre_parser_->pre ();
        this->genre_parser_->_pre_impl ();
        this->genre_parser_->_characters (s);
        this->genre_parser_->_post_impl ();
        const ::std::string& tmp (this->genre_parser_->post_string ());
        this->genre (tmp);
      }

      return true;
    }

    return false;
  }

  void AlbumID3_pskel::
  _pre_a_validate ()
  {
    this->v_state_attr_stack_.push ();
    v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());

    as.id = false;
    as.name = false;
    as.songCount = false;
    as.duration = false;
    as.created = false;
  }

  void AlbumID3_pskel::
  _post_a_validate ()
  {
    v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());

    if (!as.id)
      this->_expected_attribute (
        "", "id");
    if (!as.name)
      this->_expected_attribute (
        "", "name");
    if (!as.songCount)
      this->_expected_attribute (
        "", "songCount");
    if (!as.duration)
      this->_expected_attribute (
        "", "duration");
    if (!as.created)
      this->_expected_attribute (
        "", "created");

    this->v_state_attr_stack_.pop ();
  }

  // Attribute validation and dispatch functions for Directory_pskel.
  //
  bool Directory_pskel::
  _attribute_impl_phase_one (const ::xml_schema::ro_string& ns,
                             const ::xml_schema::ro_string& n,
                             const ::xml_schema::ro_string& s)
  {
    if (n == "id" && ns.empty ())
    {
      if (this->id_parser_)
      {
        this->id_parser_->pre ();
        this->id_parser_->_pre_impl ();
        this->id_parser_->_characters (s);
        this->id_parser_->_post_impl ();
        const ::std::string& tmp (this->id_parser_->post_string ());
        this->id (tmp);
      }

      static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ())->id = true;
      return true;
    }

    if (n == "parent" && ns.empty ())
    {
      if (this->parent_parser_)
      {
        this->parent_parser_->pre ();
        this->parent_parser_->_pre_impl ();
        this->parent_parser_->_characters (s);
        this->parent_parser_->_post_impl ();
        const ::std::string& tmp (this->parent_parser_->post_string ());
        this->parent (tmp);
      }

      return true;
    }

    if (n == "name" && ns.empty ())
    {
      if (this->name_parser_)
      {
        this->name_parser_->pre ();
        this->name_parser_->_pre_impl ();
        this->name_parser_->_characters (s);
        this->name_parser_->_post_impl ();
        const ::std::string& tmp (this->name_parser_->post_string ());
        this->name (tmp);
      }

      static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ())->name = true;
      return true;
    }

    if (n == "starred" && ns.empty ())
    {
      if (this->starred_parser_)
      {
        this->starred_parser_->pre ();
        this->starred_parser_->_pre_impl ();
        this->starred_parser_->_characters (s);
        this->starred_parser_->_post_impl ();
        const ::xml_schema::date_time& tmp (this->starred_parser_->post_date_time ());
        this->starred (tmp);
      }

      return true;
    }

    return false;
  }

  void Directory_pskel::
  _pre_a_validate ()
  {
    this->v_state_attr_stack_.push ();
    v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());

    as.id = false;
    as.name = false;
  }

  void Directory_pskel::
  _post_a_validate ()
  {
    v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());

    if (!as.id)
      this->_expected_attribute (
        "", "id");
    if (!as.name)
      this->_expected_attribute (
        "", "name");

    this->v_state_attr_stack_.pop ();
  }

  // Attribute validation and dispatch functions for Child_pskel.
  //
  bool Child_pskel::
  _attribute_impl_phase_one (const ::xml_schema::ro_string& ns,
                             const ::xml_schema::ro_string& n,
                             const ::xml_schema::ro_string& s)
  {
    if (n == "id" && ns.empty ())
    {
      if (this->id_parser_)
      {
        this->id_parser_->pre ();
        this->id_parser_->_pre_impl ();
        this->id_parser_->_characters (s);
        this->id_parser_->_post_impl ();
        const ::std::string& tmp (this->id_parser_->post_string ());
        this->id (tmp);
      }

      static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ())->id = true;
      return true;
    }

    if (n == "parent" && ns.empty ())
    {
      if (this->parent_parser_)
      {
        this->parent_parser_->pre ();
        this->parent_parser_->_pre_impl ();
        this->parent_parser_->_characters (s);
        this->parent_parser_->_post_impl ();
        const ::std::string& tmp (this->parent_parser_->post_string ());
        this->parent (tmp);
      }

      return true;
    }

    if (n == "isDir" && ns.empty ())
    {
      if (this->isDir_parser_)
      {
        this->isDir_parser_->pre ();
        this->isDir_parser_->_pre_impl ();
        this->isDir_parser_->_characters (s);
        this->isDir_parser_->_post_impl ();
        bool tmp (this->isDir_parser_->post_boolean ());
        this->isDir (tmp);
      }

      static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ())->isDir = true;
      return true;
    }

    if (n == "title" && ns.empty ())
    {
      if (this->title_parser_)
      {
        this->title_parser_->pre ();
        this->title_parser_->_pre_impl ();
        this->title_parser_->_characters (s);
        this->title_parser_->_post_impl ();
        const ::std::string& tmp (this->title_parser_->post_string ());
        this->title (tmp);
      }

      static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ())->title = true;
      return true;
    }

    if (n == "album" && ns.empty ())
    {
      if (this->album_parser_)
      {
        this->album_parser_->pre ();
        this->album_parser_->_pre_impl ();
        this->album_parser_->_characters (s);
        this->album_parser_->_post_impl ();
        const ::std::string& tmp (this->album_parser_->post_string ());
        this->album (tmp);
      }

      return true;
    }

    if (n == "artist" && ns.empty ())
    {
      if (this->artist_parser_)
      {
        this->artist_parser_->pre ();
        this->artist_parser_->_pre_impl ();
        this->artist_parser_->_characters (s);
        this->artist_parser_->_post_impl ();
        const ::std::string& tmp (this->artist_parser_->post_string ());
        this->artist (tmp);
      }

      return true;
    }

    if (n == "track" && ns.empty ())
    {
      if (this->track_parser_)
      {
        this->track_parser_->pre ();
        this->track_parser_->_pre_impl ();
        this->track_parser_->_characters (s);
        this->track_parser_->_post_impl ();
        int tmp (this->track_parser_->post_int ());
        this->track (tmp);
      }

      return true;
    }

    if (n == "year" && ns.empty ())
    {
      if (this->year_parser_)
      {
        this->year_parser_->pre ();
        this->year_parser_->_pre_impl ();
        this->year_parser_->_characters (s);
        this->year_parser_->_post_impl ();
        int tmp (this->year_parser_->post_int ());
        this->year (tmp);
      }

      return true;
    }

    if (n == "genre" && ns.empty ())
    {
      if (this->genre_parser_)
      {
        this->genre_parser_->pre ();
        this->genre_parser_->_pre_impl ();
        this->genre_parser_->_characters (s);
        this->genre_parser_->_post_impl ();
        const ::std::string& tmp (this->genre_parser_->post_string ());
        this->genre (tmp);
      }

      return true;
    }

    if (n == "coverArt" && ns.empty ())
    {
      if (this->coverArt_parser_)
      {
        this->coverArt_parser_->pre ();
        this->coverArt_parser_->_pre_impl ();
        this->coverArt_parser_->_characters (s);
        this->coverArt_parser_->_post_impl ();
        const ::std::string& tmp (this->coverArt_parser_->post_string ());
        this->coverArt (tmp);
      }

      return true;
    }

    if (n == "size" && ns.empty ())
    {
      if (this->size_parser_)
      {
        this->size_parser_->pre ();
        this->size_parser_->_pre_impl ();
        this->size_parser_->_characters (s);
        this->size_parser_->_post_impl ();
        long long tmp (this->size_parser_->post_long ());
        this->size (tmp);
      }

      return true;
    }

    if (n == "contentType" && ns.empty ())
    {
      if (this->contentType_parser_)
      {
        this->contentType_parser_->pre ();
        this->contentType_parser_->_pre_impl ();
        this->contentType_parser_->_characters (s);
        this->contentType_parser_->_post_impl ();
        const ::std::string& tmp (this->contentType_parser_->post_string ());
        this->contentType (tmp);
      }

      return true;
    }

    if (n == "suffix" && ns.empty ())
    {
      if (this->suffix_parser_)
      {
        this->suffix_parser_->pre ();
        this->suffix_parser_->_pre_impl ();
        this->suffix_parser_->_characters (s);
        this->suffix_parser_->_post_impl ();
        const ::std::string& tmp (this->suffix_parser_->post_string ());
        this->suffix (tmp);
      }

      return true;
    }

    if (n == "transcodedContentType" && ns.empty ())
    {
      if (this->transcodedContentType_parser_)
      {
        this->transcodedContentType_parser_->pre ();
        this->transcodedContentType_parser_->_pre_impl ();
        this->transcodedContentType_parser_->_characters (s);
        this->transcodedContentType_parser_->_post_impl ();
        const ::std::string& tmp (this->transcodedContentType_parser_->post_string ());
        this->transcodedContentType (tmp);
      }

      return true;
    }

    if (n == "transcodedSuffix" && ns.empty ())
    {
      if (this->transcodedSuffix_parser_)
      {
        this->transcodedSuffix_parser_->pre ();
        this->transcodedSuffix_parser_->_pre_impl ();
        this->transcodedSuffix_parser_->_characters (s);
        this->transcodedSuffix_parser_->_post_impl ();
        const ::std::string& tmp (this->transcodedSuffix_parser_->post_string ());
        this->transcodedSuffix (tmp);
      }

      return true;
    }

    if (n == "duration" && ns.empty ())
    {
      if (this->duration_parser_)
      {
        this->duration_parser_->pre ();
        this->duration_parser_->_pre_impl ();
        this->duration_parser_->_characters (s);
        this->duration_parser_->_post_impl ();
        int tmp (this->duration_parser_->post_int ());
        this->duration (tmp);
      }

      return true;
    }

    if (n == "bitRate" && ns.empty ())
    {
      if (this->bitRate_parser_)
      {
        this->bitRate_parser_->pre ();
        this->bitRate_parser_->_pre_impl ();
        this->bitRate_parser_->_characters (s);
        this->bitRate_parser_->_post_impl ();
        int tmp (this->bitRate_parser_->post_int ());
        this->bitRate (tmp);
      }

      return true;
    }

    if (n == "path" && ns.empty ())
    {
      if (this->path_parser_)
      {
        this->path_parser_->pre ();
        this->path_parser_->_pre_impl ();
        this->path_parser_->_characters (s);
        this->path_parser_->_post_impl ();
        const ::std::string& tmp (this->path_parser_->post_string ());
        this->path (tmp);
      }

      return true;
    }

    if (n == "isVideo" && ns.empty ())
    {
      if (this->isVideo_parser_)
      {
        this->isVideo_parser_->pre ();
        this->isVideo_parser_->_pre_impl ();
        this->isVideo_parser_->_characters (s);
        this->isVideo_parser_->_post_impl ();
        bool tmp (this->isVideo_parser_->post_boolean ());
        this->isVideo (tmp);
      }

      return true;
    }

    if (n == "userRating" && ns.empty ())
    {
      if (this->userRating_parser_)
      {
        this->userRating_parser_->pre ();
        this->userRating_parser_->_pre_impl ();
        this->userRating_parser_->_characters (s);
        this->userRating_parser_->_post_impl ();
        this->userRating_parser_->post_UserRating ();
        this->userRating ();
      }

      return true;
    }

    if (n == "averageRating" && ns.empty ())
    {
      if (this->averageRating_parser_)
      {
        this->averageRating_parser_->pre ();
        this->averageRating_parser_->_pre_impl ();
        this->averageRating_parser_->_characters (s);
        this->averageRating_parser_->_post_impl ();
        this->averageRating_parser_->post_AverageRating ();
        this->averageRating ();
      }

      return true;
    }

    if (n == "discNumber" && ns.empty ())
    {
      if (this->discNumber_parser_)
      {
        this->discNumber_parser_->pre ();
        this->discNumber_parser_->_pre_impl ();
        this->discNumber_parser_->_characters (s);
        this->discNumber_parser_->_post_impl ();
        int tmp (this->discNumber_parser_->post_int ());
        this->discNumber (tmp);
      }

      return true;
    }

    if (n == "created" && ns.empty ())
    {
      if (this->created_parser_)
      {
        this->created_parser_->pre ();
        this->created_parser_->_pre_impl ();
        this->created_parser_->_characters (s);
        this->created_parser_->_post_impl ();
        const ::xml_schema::date_time& tmp (this->created_parser_->post_date_time ());
        this->created (tmp);
      }

      return true;
    }

    if (n == "starred" && ns.empty ())
    {
      if (this->starred_parser_)
      {
        this->starred_parser_->pre ();
        this->starred_parser_->_pre_impl ();
        this->starred_parser_->_characters (s);
        this->starred_parser_->_post_impl ();
        const ::xml_schema::date_time& tmp (this->starred_parser_->post_date_time ());
        this->starred (tmp);
      }

      return true;
    }

    if (n == "albumId" && ns.empty ())
    {
      if (this->albumId_parser_)
      {
        this->albumId_parser_->pre ();
        this->albumId_parser_->_pre_impl ();
        this->albumId_parser_->_characters (s);
        this->albumId_parser_->_post_impl ();
        const ::std::string& tmp (this->albumId_parser_->post_string ());
        this->albumId (tmp);
      }

      return true;
    }

    if (n == "artistId" && ns.empty ())
    {
      if (this->artistId_parser_)
      {
        this->artistId_parser_->pre ();
        this->artistId_parser_->_pre_impl ();
        this->artistId_parser_->_characters (s);
        this->artistId_parser_->_post_impl ();
        const ::std::string& tmp (this->artistId_parser_->post_string ());
        this->artistId (tmp);
      }

      return true;
    }

    if (n == "type" && ns.empty ())
    {
      if (this->type_parser_)
      {
        this->type_parser_->pre ();
        this->type_parser_->_pre_impl ();
        this->type_parser_->_characters (s);
        this->type_parser_->_post_impl ();
        this->type_parser_->post_MediaType ();
        this->type ();
      }

      return true;
    }

    if (n == "bookmarkPosition" && ns.empty ())
    {
      if (this->bookmarkPosition_parser_)
      {
        this->bookmarkPosition_parser_->pre ();
        this->bookmarkPosition_parser_->_pre_impl ();
        this->bookmarkPosition_parser_->_characters (s);
        this->bookmarkPosition_parser_->_post_impl ();
        long long tmp (this->bookmarkPosition_parser_->post_long ());
        this->bookmarkPosition (tmp);
      }

      return true;
    }

    return false;
  }

  void Child_pskel::
  _pre_a_validate ()
  {
    this->v_state_attr_stack_.push ();
    v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());

    as.id = false;
    as.isDir = false;
    as.title = false;
  }

  void Child_pskel::
  _post_a_validate ()
  {
    v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());

    if (!as.id)
      this->_expected_attribute (
        "", "id");
    if (!as.isDir)
      this->_expected_attribute (
        "", "isDir");
    if (!as.title)
      this->_expected_attribute (
        "", "title");

    this->v_state_attr_stack_.pop ();
  }

  // Attribute validation and dispatch functions for NowPlayingEntry_pskel.
  //
  bool NowPlayingEntry_pskel::
  _attribute_impl_phase_one (const ::xml_schema::ro_string& ns,
                             const ::xml_schema::ro_string& n,
                             const ::xml_schema::ro_string& s)
  {
    if (n == "username" && ns.empty ())
    {
      if (this->username_parser_)
      {
        this->username_parser_->pre ();
        this->username_parser_->_pre_impl ();
        this->username_parser_->_characters (s);
        this->username_parser_->_post_impl ();
        const ::std::string& tmp (this->username_parser_->post_string ());
        this->username (tmp);
      }

      static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ())->username = true;
      return true;
    }

    if (n == "minutesAgo" && ns.empty ())
    {
      if (this->minutesAgo_parser_)
      {
        this->minutesAgo_parser_->pre ();
        this->minutesAgo_parser_->_pre_impl ();
        this->minutesAgo_parser_->_characters (s);
        this->minutesAgo_parser_->_post_impl ();
        int tmp (this->minutesAgo_parser_->post_int ());
        this->minutesAgo (tmp);
      }

      static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ())->minutesAgo = true;
      return true;
    }

    if (n == "playerId" && ns.empty ())
    {
      if (this->playerId_parser_)
      {
        this->playerId_parser_->pre ();
        this->playerId_parser_->_pre_impl ();
        this->playerId_parser_->_characters (s);
        this->playerId_parser_->_post_impl ();
        int tmp (this->playerId_parser_->post_int ());
        this->playerId (tmp);
      }

      static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ())->playerId = true;
      return true;
    }

    if (n == "playerName" && ns.empty ())
    {
      if (this->playerName_parser_)
      {
        this->playerName_parser_->pre ();
        this->playerName_parser_->_pre_impl ();
        this->playerName_parser_->_characters (s);
        this->playerName_parser_->_post_impl ();
        const ::std::string& tmp (this->playerName_parser_->post_string ());
        this->playerName (tmp);
      }

      return true;
    }

    return this->::restapi::Child_pskel::_attribute_impl_phase_one (ns, n, s);
  }

  void NowPlayingEntry_pskel::
  _pre_a_validate ()
  {
    this->v_state_attr_stack_.push ();
    v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());

    as.username = false;
    as.minutesAgo = false;
    as.playerId = false;
    this->::restapi::Child_pskel::_pre_a_validate ();
  }

  void NowPlayingEntry_pskel::
  _post_a_validate ()
  {
    this->::restapi::Child_pskel::_post_a_validate ();

    v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());

    if (!as.username)
      this->_expected_attribute (
        "", "username");
    if (!as.minutesAgo)
      this->_expected_attribute (
        "", "minutesAgo");
    if (!as.playerId)
      this->_expected_attribute (
        "", "playerId");

    this->v_state_attr_stack_.pop ();
  }

  // Attribute validation and dispatch functions for SearchResult_pskel.
  //
  bool SearchResult_pskel::
  _attribute_impl_phase_one (const ::xml_schema::ro_string& ns,
                             const ::xml_schema::ro_string& n,
                             const ::xml_schema::ro_string& s)
  {
    if (n == "offset" && ns.empty ())
    {
      if (this->offset_parser_)
      {
        this->offset_parser_->pre ();
        this->offset_parser_->_pre_impl ();
        this->offset_parser_->_characters (s);
        this->offset_parser_->_post_impl ();
        int tmp (this->offset_parser_->post_int ());
        this->offset (tmp);
      }

      static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ())->offset = true;
      return true;
    }

    if (n == "totalHits" && ns.empty ())
    {
      if (this->totalHits_parser_)
      {
        this->totalHits_parser_->pre ();
        this->totalHits_parser_->_pre_impl ();
        this->totalHits_parser_->_characters (s);
        this->totalHits_parser_->_post_impl ();
        int tmp (this->totalHits_parser_->post_int ());
        this->totalHits (tmp);
      }

      static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ())->totalHits = true;
      return true;
    }

    return false;
  }

  void SearchResult_pskel::
  _pre_a_validate ()
  {
    this->v_state_attr_stack_.push ();
    v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());

    as.offset = false;
    as.totalHits = false;
  }

  void SearchResult_pskel::
  _post_a_validate ()
  {
    v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());

    if (!as.offset)
      this->_expected_attribute (
        "", "offset");
    if (!as.totalHits)
      this->_expected_attribute (
        "", "totalHits");

    this->v_state_attr_stack_.pop ();
  }

  // Attribute validation and dispatch functions for Playlist_pskel.
  //
  bool Playlist_pskel::
  _attribute_impl_phase_one (const ::xml_schema::ro_string& ns,
                             const ::xml_schema::ro_string& n,
                             const ::xml_schema::ro_string& s)
  {
    if (n == "id" && ns.empty ())
    {
      if (this->id_parser_)
      {
        this->id_parser_->pre ();
        this->id_parser_->_pre_impl ();
        this->id_parser_->_characters (s);
        this->id_parser_->_post_impl ();
        const ::std::string& tmp (this->id_parser_->post_string ());
        this->id (tmp);
      }

      static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ())->id = true;
      return true;
    }

    if (n == "name" && ns.empty ())
    {
      if (this->name_parser_)
      {
        this->name_parser_->pre ();
        this->name_parser_->_pre_impl ();
        this->name_parser_->_characters (s);
        this->name_parser_->_post_impl ();
        const ::std::string& tmp (this->name_parser_->post_string ());
        this->name (tmp);
      }

      static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ())->name = true;
      return true;
    }

    if (n == "comment" && ns.empty ())
    {
      if (this->comment_parser_)
      {
        this->comment_parser_->pre ();
        this->comment_parser_->_pre_impl ();
        this->comment_parser_->_characters (s);
        this->comment_parser_->_post_impl ();
        const ::std::string& tmp (this->comment_parser_->post_string ());
        this->comment (tmp);
      }

      return true;
    }

    if (n == "owner" && ns.empty ())
    {
      if (this->owner_parser_)
      {
        this->owner_parser_->pre ();
        this->owner_parser_->_pre_impl ();
        this->owner_parser_->_characters (s);
        this->owner_parser_->_post_impl ();
        const ::std::string& tmp (this->owner_parser_->post_string ());
        this->owner (tmp);
      }

      return true;
    }

    if (n == "public" && ns.empty ())
    {
      if (this->public__parser_)
      {
        this->public__parser_->pre ();
        this->public__parser_->_pre_impl ();
        this->public__parser_->_characters (s);
        this->public__parser_->_post_impl ();
        bool tmp (this->public__parser_->post_boolean ());
        this->public_ (tmp);
      }

      return true;
    }

    if (n == "songCount" && ns.empty ())
    {
      if (this->songCount_parser_)
      {
        this->songCount_parser_->pre ();
        this->songCount_parser_->_pre_impl ();
        this->songCount_parser_->_characters (s);
        this->songCount_parser_->_post_impl ();
        int tmp (this->songCount_parser_->post_int ());
        this->songCount (tmp);
      }

      static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ())->songCount = true;
      return true;
    }

    if (n == "duration" && ns.empty ())
    {
      if (this->duration_parser_)
      {
        this->duration_parser_->pre ();
        this->duration_parser_->_pre_impl ();
        this->duration_parser_->_characters (s);
        this->duration_parser_->_post_impl ();
        int tmp (this->duration_parser_->post_int ());
        this->duration (tmp);
      }

      static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ())->duration = true;
      return true;
    }

    if (n == "created" && ns.empty ())
    {
      if (this->created_parser_)
      {
        this->created_parser_->pre ();
        this->created_parser_->_pre_impl ();
        this->created_parser_->_characters (s);
        this->created_parser_->_post_impl ();
        const ::xml_schema::date_time& tmp (this->created_parser_->post_date_time ());
        this->created (tmp);
      }

      static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ())->created = true;
      return true;
    }

    return false;
  }

  void Playlist_pskel::
  _pre_a_validate ()
  {
    this->v_state_attr_stack_.push ();
    v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());

    as.id = false;
    as.name = false;
    as.songCount = false;
    as.duration = false;
    as.created = false;
  }

  void Playlist_pskel::
  _post_a_validate ()
  {
    v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());

    if (!as.id)
      this->_expected_attribute (
        "", "id");
    if (!as.name)
      this->_expected_attribute (
        "", "name");
    if (!as.songCount)
      this->_expected_attribute (
        "", "songCount");
    if (!as.duration)
      this->_expected_attribute (
        "", "duration");
    if (!as.created)
      this->_expected_attribute (
        "", "created");

    this->v_state_attr_stack_.pop ();
  }

  // Attribute validation and dispatch functions for JukeboxStatus_pskel.
  //
  bool JukeboxStatus_pskel::
  _attribute_impl_phase_one (const ::xml_schema::ro_string& ns,
                             const ::xml_schema::ro_string& n,
                             const ::xml_schema::ro_string& s)
  {
    if (n == "currentIndex" && ns.empty ())
    {
      if (this->currentIndex_parser_)
      {
        this->currentIndex_parser_->pre ();
        this->currentIndex_parser_->_pre_impl ();
        this->currentIndex_parser_->_characters (s);
        this->currentIndex_parser_->_post_impl ();
        int tmp (this->currentIndex_parser_->post_int ());
        this->currentIndex (tmp);
      }

      static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ())->currentIndex = true;
      return true;
    }

    if (n == "playing" && ns.empty ())
    {
      if (this->playing_parser_)
      {
        this->playing_parser_->pre ();
        this->playing_parser_->_pre_impl ();
        this->playing_parser_->_characters (s);
        this->playing_parser_->_post_impl ();
        bool tmp (this->playing_parser_->post_boolean ());
        this->playing (tmp);
      }

      static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ())->playing = true;
      return true;
    }

    if (n == "gain" && ns.empty ())
    {
      if (this->gain_parser_)
      {
        this->gain_parser_->pre ();
        this->gain_parser_->_pre_impl ();
        this->gain_parser_->_characters (s);
        this->gain_parser_->_post_impl ();
        float tmp (this->gain_parser_->post_float ());
        this->gain (tmp);
      }

      static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ())->gain = true;
      return true;
    }

    if (n == "position" && ns.empty ())
    {
      if (this->position_parser_)
      {
        this->position_parser_->pre ();
        this->position_parser_->_pre_impl ();
        this->position_parser_->_characters (s);
        this->position_parser_->_post_impl ();
        int tmp (this->position_parser_->post_int ());
        this->position (tmp);
      }

      return true;
    }

    return false;
  }

  void JukeboxStatus_pskel::
  _pre_a_validate ()
  {
    this->v_state_attr_stack_.push ();
    v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());

    as.currentIndex = false;
    as.playing = false;
    as.gain = false;
  }

  void JukeboxStatus_pskel::
  _post_a_validate ()
  {
    v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());

    if (!as.currentIndex)
      this->_expected_attribute (
        "", "currentIndex");
    if (!as.playing)
      this->_expected_attribute (
        "", "playing");
    if (!as.gain)
      this->_expected_attribute (
        "", "gain");

    this->v_state_attr_stack_.pop ();
  }

  // Attribute validation and dispatch functions for ChatMessage_pskel.
  //
  bool ChatMessage_pskel::
  _attribute_impl_phase_one (const ::xml_schema::ro_string& ns,
                             const ::xml_schema::ro_string& n,
                             const ::xml_schema::ro_string& s)
  {
    if (n == "username" && ns.empty ())
    {
      if (this->username_parser_)
      {
        this->username_parser_->pre ();
        this->username_parser_->_pre_impl ();
        this->username_parser_->_characters (s);
        this->username_parser_->_post_impl ();
        const ::std::string& tmp (this->username_parser_->post_string ());
        this->username (tmp);
      }

      static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ())->username = true;
      return true;
    }

    if (n == "time" && ns.empty ())
    {
      if (this->time_parser_)
      {
        this->time_parser_->pre ();
        this->time_parser_->_pre_impl ();
        this->time_parser_->_characters (s);
        this->time_parser_->_post_impl ();
        long long tmp (this->time_parser_->post_long ());
        this->time (tmp);
      }

      static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ())->time = true;
      return true;
    }

    if (n == "message" && ns.empty ())
    {
      if (this->message_parser_)
      {
        this->message_parser_->pre ();
        this->message_parser_->_pre_impl ();
        this->message_parser_->_characters (s);
        this->message_parser_->_post_impl ();
        const ::std::string& tmp (this->message_parser_->post_string ());
        this->message (tmp);
      }

      static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ())->message = true;
      return true;
    }

    return false;
  }

  void ChatMessage_pskel::
  _pre_a_validate ()
  {
    this->v_state_attr_stack_.push ();
    v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());

    as.username = false;
    as.time = false;
    as.message = false;
  }

  void ChatMessage_pskel::
  _post_a_validate ()
  {
    v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());

    if (!as.username)
      this->_expected_attribute (
        "", "username");
    if (!as.time)
      this->_expected_attribute (
        "", "time");
    if (!as.message)
      this->_expected_attribute (
        "", "message");

    this->v_state_attr_stack_.pop ();
  }

  // Attribute validation and dispatch functions for Lyrics_pskel.
  //
  bool Lyrics_pskel::
  _attribute_impl_phase_one (const ::xml_schema::ro_string& ns,
                             const ::xml_schema::ro_string& n,
                             const ::xml_schema::ro_string& s)
  {
    if (n == "artist" && ns.empty ())
    {
      if (this->artist_parser_)
      {
        this->artist_parser_->pre ();
        this->artist_parser_->_pre_impl ();
        this->artist_parser_->_characters (s);
        this->artist_parser_->_post_impl ();
        const ::std::string& tmp (this->artist_parser_->post_string ());
        this->artist (tmp);
      }

      return true;
    }

    if (n == "title" && ns.empty ())
    {
      if (this->title_parser_)
      {
        this->title_parser_->pre ();
        this->title_parser_->_pre_impl ();
        this->title_parser_->_characters (s);
        this->title_parser_->_post_impl ();
        const ::std::string& tmp (this->title_parser_->post_string ());
        this->title (tmp);
      }

      return true;
    }

    return false;
  }

  // Attribute validation and dispatch functions for PodcastChannel_pskel.
  //
  bool PodcastChannel_pskel::
  _attribute_impl_phase_one (const ::xml_schema::ro_string& ns,
                             const ::xml_schema::ro_string& n,
                             const ::xml_schema::ro_string& s)
  {
    if (n == "id" && ns.empty ())
    {
      if (this->id_parser_)
      {
        this->id_parser_->pre ();
        this->id_parser_->_pre_impl ();
        this->id_parser_->_characters (s);
        this->id_parser_->_post_impl ();
        const ::std::string& tmp (this->id_parser_->post_string ());
        this->id (tmp);
      }

      static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ())->id = true;
      return true;
    }

    if (n == "url" && ns.empty ())
    {
      if (this->url_parser_)
      {
        this->url_parser_->pre ();
        this->url_parser_->_pre_impl ();
        this->url_parser_->_characters (s);
        this->url_parser_->_post_impl ();
        const ::std::string& tmp (this->url_parser_->post_string ());
        this->url (tmp);
      }

      static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ())->url = true;
      return true;
    }

    if (n == "title" && ns.empty ())
    {
      if (this->title_parser_)
      {
        this->title_parser_->pre ();
        this->title_parser_->_pre_impl ();
        this->title_parser_->_characters (s);
        this->title_parser_->_post_impl ();
        const ::std::string& tmp (this->title_parser_->post_string ());
        this->title (tmp);
      }

      return true;
    }

    if (n == "description" && ns.empty ())
    {
      if (this->description_parser_)
      {
        this->description_parser_->pre ();
        this->description_parser_->_pre_impl ();
        this->description_parser_->_characters (s);
        this->description_parser_->_post_impl ();
        const ::std::string& tmp (this->description_parser_->post_string ());
        this->description (tmp);
      }

      return true;
    }

    if (n == "status" && ns.empty ())
    {
      if (this->status_parser_)
      {
        this->status_parser_->pre ();
        this->status_parser_->_pre_impl ();
        this->status_parser_->_characters (s);
        this->status_parser_->_post_impl ();
        this->status_parser_->post_PodcastStatus ();
        this->status ();
      }

      static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ())->status = true;
      return true;
    }

    if (n == "errorMessage" && ns.empty ())
    {
      if (this->errorMessage_parser_)
      {
        this->errorMessage_parser_->pre ();
        this->errorMessage_parser_->_pre_impl ();
        this->errorMessage_parser_->_characters (s);
        this->errorMessage_parser_->_post_impl ();
        const ::std::string& tmp (this->errorMessage_parser_->post_string ());
        this->errorMessage (tmp);
      }

      return true;
    }

    return false;
  }

  void PodcastChannel_pskel::
  _pre_a_validate ()
  {
    this->v_state_attr_stack_.push ();
    v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());

    as.id = false;
    as.url = false;
    as.status = false;
  }

  void PodcastChannel_pskel::
  _post_a_validate ()
  {
    v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());

    if (!as.id)
      this->_expected_attribute (
        "", "id");
    if (!as.url)
      this->_expected_attribute (
        "", "url");
    if (!as.status)
      this->_expected_attribute (
        "", "status");

    this->v_state_attr_stack_.pop ();
  }

  // Attribute validation and dispatch functions for PodcastEpisode_pskel.
  //
  bool PodcastEpisode_pskel::
  _attribute_impl_phase_one (const ::xml_schema::ro_string& ns,
                             const ::xml_schema::ro_string& n,
                             const ::xml_schema::ro_string& s)
  {
    if (n == "streamId" && ns.empty ())
    {
      if (this->streamId_parser_)
      {
        this->streamId_parser_->pre ();
        this->streamId_parser_->_pre_impl ();
        this->streamId_parser_->_characters (s);
        this->streamId_parser_->_post_impl ();
        const ::std::string& tmp (this->streamId_parser_->post_string ());
        this->streamId (tmp);
      }

      return true;
    }

    if (n == "description" && ns.empty ())
    {
      if (this->description_parser_)
      {
        this->description_parser_->pre ();
        this->description_parser_->_pre_impl ();
        this->description_parser_->_characters (s);
        this->description_parser_->_post_impl ();
        const ::std::string& tmp (this->description_parser_->post_string ());
        this->description (tmp);
      }

      return true;
    }

    if (n == "status" && ns.empty ())
    {
      if (this->status_parser_)
      {
        this->status_parser_->pre ();
        this->status_parser_->_pre_impl ();
        this->status_parser_->_characters (s);
        this->status_parser_->_post_impl ();
        this->status_parser_->post_PodcastStatus ();
        this->status ();
      }

      static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ())->status = true;
      return true;
    }

    if (n == "publishDate" && ns.empty ())
    {
      if (this->publishDate_parser_)
      {
        this->publishDate_parser_->pre ();
        this->publishDate_parser_->_pre_impl ();
        this->publishDate_parser_->_characters (s);
        this->publishDate_parser_->_post_impl ();
        const ::xml_schema::date_time& tmp (this->publishDate_parser_->post_date_time ());
        this->publishDate (tmp);
      }

      return true;
    }

    return this->::restapi::Child_pskel::_attribute_impl_phase_one (ns, n, s);
  }

  void PodcastEpisode_pskel::
  _pre_a_validate ()
  {
    this->v_state_attr_stack_.push ();
    v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());

    as.status = false;
    this->::restapi::Child_pskel::_pre_a_validate ();
  }

  void PodcastEpisode_pskel::
  _post_a_validate ()
  {
    this->::restapi::Child_pskel::_post_a_validate ();

    v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());

    if (!as.status)
      this->_expected_attribute (
        "", "status");

    this->v_state_attr_stack_.pop ();
  }

  // Attribute validation and dispatch functions for InternetRadioStation_pskel.
  //
  bool InternetRadioStation_pskel::
  _attribute_impl_phase_one (const ::xml_schema::ro_string& ns,
                             const ::xml_schema::ro_string& n,
                             const ::xml_schema::ro_string& s)
  {
    if (n == "id" && ns.empty ())
    {
      if (this->id_parser_)
      {
        this->id_parser_->pre ();
        this->id_parser_->_pre_impl ();
        this->id_parser_->_characters (s);
        this->id_parser_->_post_impl ();
        const ::std::string& tmp (this->id_parser_->post_string ());
        this->id (tmp);
      }

      static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ())->id = true;
      return true;
    }

    if (n == "name" && ns.empty ())
    {
      if (this->name_parser_)
      {
        this->name_parser_->pre ();
        this->name_parser_->_pre_impl ();
        this->name_parser_->_characters (s);
        this->name_parser_->_post_impl ();
        const ::std::string& tmp (this->name_parser_->post_string ());
        this->name (tmp);
      }

      static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ())->name = true;
      return true;
    }

    if (n == "streamUrl" && ns.empty ())
    {
      if (this->streamUrl_parser_)
      {
        this->streamUrl_parser_->pre ();
        this->streamUrl_parser_->_pre_impl ();
        this->streamUrl_parser_->_characters (s);
        this->streamUrl_parser_->_post_impl ();
        const ::std::string& tmp (this->streamUrl_parser_->post_string ());
        this->streamUrl (tmp);
      }

      static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ())->streamUrl = true;
      return true;
    }

    if (n == "homePageUrl" && ns.empty ())
    {
      if (this->homePageUrl_parser_)
      {
        this->homePageUrl_parser_->pre ();
        this->homePageUrl_parser_->_pre_impl ();
        this->homePageUrl_parser_->_characters (s);
        this->homePageUrl_parser_->_post_impl ();
        const ::std::string& tmp (this->homePageUrl_parser_->post_string ());
        this->homePageUrl (tmp);
      }

      return true;
    }

    return false;
  }

  void InternetRadioStation_pskel::
  _pre_a_validate ()
  {
    this->v_state_attr_stack_.push ();
    v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());

    as.id = false;
    as.name = false;
    as.streamUrl = false;
  }

  void InternetRadioStation_pskel::
  _post_a_validate ()
  {
    v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());

    if (!as.id)
      this->_expected_attribute (
        "", "id");
    if (!as.name)
      this->_expected_attribute (
        "", "name");
    if (!as.streamUrl)
      this->_expected_attribute (
        "", "streamUrl");

    this->v_state_attr_stack_.pop ();
  }

  // Attribute validation and dispatch functions for Bookmark_pskel.
  //
  bool Bookmark_pskel::
  _attribute_impl_phase_one (const ::xml_schema::ro_string& ns,
                             const ::xml_schema::ro_string& n,
                             const ::xml_schema::ro_string& s)
  {
    if (n == "position" && ns.empty ())
    {
      if (this->position_parser_)
      {
        this->position_parser_->pre ();
        this->position_parser_->_pre_impl ();
        this->position_parser_->_characters (s);
        this->position_parser_->_post_impl ();
        long long tmp (this->position_parser_->post_long ());
        this->position (tmp);
      }

      static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ())->position = true;
      return true;
    }

    if (n == "username" && ns.empty ())
    {
      if (this->username_parser_)
      {
        this->username_parser_->pre ();
        this->username_parser_->_pre_impl ();
        this->username_parser_->_characters (s);
        this->username_parser_->_post_impl ();
        const ::std::string& tmp (this->username_parser_->post_string ());
        this->username (tmp);
      }

      static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ())->username = true;
      return true;
    }

    if (n == "comment" && ns.empty ())
    {
      if (this->comment_parser_)
      {
        this->comment_parser_->pre ();
        this->comment_parser_->_pre_impl ();
        this->comment_parser_->_characters (s);
        this->comment_parser_->_post_impl ();
        const ::std::string& tmp (this->comment_parser_->post_string ());
        this->comment (tmp);
      }

      return true;
    }

    if (n == "created" && ns.empty ())
    {
      if (this->created_parser_)
      {
        this->created_parser_->pre ();
        this->created_parser_->_pre_impl ();
        this->created_parser_->_characters (s);
        this->created_parser_->_post_impl ();
        const ::xml_schema::date_time& tmp (this->created_parser_->post_date_time ());
        this->created (tmp);
      }

      static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ())->created = true;
      return true;
    }

    if (n == "changed" && ns.empty ())
    {
      if (this->changed_parser_)
      {
        this->changed_parser_->pre ();
        this->changed_parser_->_pre_impl ();
        this->changed_parser_->_characters (s);
        this->changed_parser_->_post_impl ();
        const ::xml_schema::date_time& tmp (this->changed_parser_->post_date_time ());
        this->changed (tmp);
      }

      static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ())->changed = true;
      return true;
    }

    return false;
  }

  void Bookmark_pskel::
  _pre_a_validate ()
  {
    this->v_state_attr_stack_.push ();
    v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());

    as.position = false;
    as.username = false;
    as.created = false;
    as.changed = false;
  }

  void Bookmark_pskel::
  _post_a_validate ()
  {
    v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());

    if (!as.position)
      this->_expected_attribute (
        "", "position");
    if (!as.username)
      this->_expected_attribute (
        "", "username");
    if (!as.created)
      this->_expected_attribute (
        "", "created");
    if (!as.changed)
      this->_expected_attribute (
        "", "changed");

    this->v_state_attr_stack_.pop ();
  }

  // Attribute validation and dispatch functions for Share_pskel.
  //
  bool Share_pskel::
  _attribute_impl_phase_one (const ::xml_schema::ro_string& ns,
                             const ::xml_schema::ro_string& n,
                             const ::xml_schema::ro_string& s)
  {
    if (n == "id" && ns.empty ())
    {
      if (this->id_parser_)
      {
        this->id_parser_->pre ();
        this->id_parser_->_pre_impl ();
        this->id_parser_->_characters (s);
        this->id_parser_->_post_impl ();
        const ::std::string& tmp (this->id_parser_->post_string ());
        this->id (tmp);
      }

      static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ())->id = true;
      return true;
    }

    if (n == "url" && ns.empty ())
    {
      if (this->url_parser_)
      {
        this->url_parser_->pre ();
        this->url_parser_->_pre_impl ();
        this->url_parser_->_characters (s);
        this->url_parser_->_post_impl ();
        const ::std::string& tmp (this->url_parser_->post_string ());
        this->url (tmp);
      }

      static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ())->url = true;
      return true;
    }

    if (n == "description" && ns.empty ())
    {
      if (this->description_parser_)
      {
        this->description_parser_->pre ();
        this->description_parser_->_pre_impl ();
        this->description_parser_->_characters (s);
        this->description_parser_->_post_impl ();
        const ::std::string& tmp (this->description_parser_->post_string ());
        this->description (tmp);
      }

      return true;
    }

    if (n == "username" && ns.empty ())
    {
      if (this->username_parser_)
      {
        this->username_parser_->pre ();
        this->username_parser_->_pre_impl ();
        this->username_parser_->_characters (s);
        this->username_parser_->_post_impl ();
        const ::std::string& tmp (this->username_parser_->post_string ());
        this->username (tmp);
      }

      static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ())->username = true;
      return true;
    }

    if (n == "created" && ns.empty ())
    {
      if (this->created_parser_)
      {
        this->created_parser_->pre ();
        this->created_parser_->_pre_impl ();
        this->created_parser_->_characters (s);
        this->created_parser_->_post_impl ();
        const ::xml_schema::date_time& tmp (this->created_parser_->post_date_time ());
        this->created (tmp);
      }

      static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ())->created = true;
      return true;
    }

    if (n == "expires" && ns.empty ())
    {
      if (this->expires_parser_)
      {
        this->expires_parser_->pre ();
        this->expires_parser_->_pre_impl ();
        this->expires_parser_->_characters (s);
        this->expires_parser_->_post_impl ();
        const ::xml_schema::date_time& tmp (this->expires_parser_->post_date_time ());
        this->expires (tmp);
      }

      return true;
    }

    if (n == "lastVisited" && ns.empty ())
    {
      if (this->lastVisited_parser_)
      {
        this->lastVisited_parser_->pre ();
        this->lastVisited_parser_->_pre_impl ();
        this->lastVisited_parser_->_characters (s);
        this->lastVisited_parser_->_post_impl ();
        const ::xml_schema::date_time& tmp (this->lastVisited_parser_->post_date_time ());
        this->lastVisited (tmp);
      }

      return true;
    }

    if (n == "visitCount" && ns.empty ())
    {
      if (this->visitCount_parser_)
      {
        this->visitCount_parser_->pre ();
        this->visitCount_parser_->_pre_impl ();
        this->visitCount_parser_->_characters (s);
        this->visitCount_parser_->_post_impl ();
        int tmp (this->visitCount_parser_->post_int ());
        this->visitCount (tmp);
      }

      static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ())->visitCount = true;
      return true;
    }

    return false;
  }

  void Share_pskel::
  _pre_a_validate ()
  {
    this->v_state_attr_stack_.push ();
    v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());

    as.id = false;
    as.url = false;
    as.username = false;
    as.created = false;
    as.visitCount = false;
  }

  void Share_pskel::
  _post_a_validate ()
  {
    v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());

    if (!as.id)
      this->_expected_attribute (
        "", "id");
    if (!as.url)
      this->_expected_attribute (
        "", "url");
    if (!as.username)
      this->_expected_attribute (
        "", "username");
    if (!as.created)
      this->_expected_attribute (
        "", "created");
    if (!as.visitCount)
      this->_expected_attribute (
        "", "visitCount");

    this->v_state_attr_stack_.pop ();
  }

  // Attribute validation and dispatch functions for License_pskel.
  //
  bool License_pskel::
  _attribute_impl_phase_one (const ::xml_schema::ro_string& ns,
                             const ::xml_schema::ro_string& n,
                             const ::xml_schema::ro_string& s)
  {
    if (n == "valid" && ns.empty ())
    {
      if (this->valid_parser_)
      {
        this->valid_parser_->pre ();
        this->valid_parser_->_pre_impl ();
        this->valid_parser_->_characters (s);
        this->valid_parser_->_post_impl ();
        bool tmp (this->valid_parser_->post_boolean ());
        this->valid (tmp);
      }

      static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ())->valid = true;
      return true;
    }

    if (n == "email" && ns.empty ())
    {
      if (this->email_parser_)
      {
        this->email_parser_->pre ();
        this->email_parser_->_pre_impl ();
        this->email_parser_->_characters (s);
        this->email_parser_->_post_impl ();
        const ::std::string& tmp (this->email_parser_->post_string ());
        this->email (tmp);
      }

      return true;
    }

    if (n == "key" && ns.empty ())
    {
      if (this->key_parser_)
      {
        this->key_parser_->pre ();
        this->key_parser_->_pre_impl ();
        this->key_parser_->_characters (s);
        this->key_parser_->_post_impl ();
        const ::std::string& tmp (this->key_parser_->post_string ());
        this->key (tmp);
      }

      return true;
    }

    if (n == "date" && ns.empty ())
    {
      if (this->date_parser_)
      {
        this->date_parser_->pre ();
        this->date_parser_->_pre_impl ();
        this->date_parser_->_characters (s);
        this->date_parser_->_post_impl ();
        const ::xml_schema::date_time& tmp (this->date_parser_->post_date_time ());
        this->date (tmp);
      }

      return true;
    }

    return false;
  }

  void License_pskel::
  _pre_a_validate ()
  {
    this->v_state_attr_stack_.push ();
    v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());

    as.valid = false;
  }

  void License_pskel::
  _post_a_validate ()
  {
    v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());

    if (!as.valid)
      this->_expected_attribute (
        "", "valid");

    this->v_state_attr_stack_.pop ();
  }

  // Attribute validation and dispatch functions for User_pskel.
  //
  bool User_pskel::
  _attribute_impl_phase_one (const ::xml_schema::ro_string& ns,
                             const ::xml_schema::ro_string& n,
                             const ::xml_schema::ro_string& s)
  {
    if (n == "username" && ns.empty ())
    {
      if (this->username_parser_)
      {
        this->username_parser_->pre ();
        this->username_parser_->_pre_impl ();
        this->username_parser_->_characters (s);
        this->username_parser_->_post_impl ();
        const ::std::string& tmp (this->username_parser_->post_string ());
        this->username (tmp);
      }

      static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ())->username = true;
      return true;
    }

    if (n == "email" && ns.empty ())
    {
      if (this->email_parser_)
      {
        this->email_parser_->pre ();
        this->email_parser_->_pre_impl ();
        this->email_parser_->_characters (s);
        this->email_parser_->_post_impl ();
        const ::std::string& tmp (this->email_parser_->post_string ());
        this->email (tmp);
      }

      return true;
    }

    if (n == "scrobblingEnabled" && ns.empty ())
    {
      if (this->scrobblingEnabled_parser_)
      {
        this->scrobblingEnabled_parser_->pre ();
        this->scrobblingEnabled_parser_->_pre_impl ();
        this->scrobblingEnabled_parser_->_characters (s);
        this->scrobblingEnabled_parser_->_post_impl ();
        bool tmp (this->scrobblingEnabled_parser_->post_boolean ());
        this->scrobblingEnabled (tmp);
      }

      static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ())->scrobblingEnabled = true;
      return true;
    }

    if (n == "adminRole" && ns.empty ())
    {
      if (this->adminRole_parser_)
      {
        this->adminRole_parser_->pre ();
        this->adminRole_parser_->_pre_impl ();
        this->adminRole_parser_->_characters (s);
        this->adminRole_parser_->_post_impl ();
        bool tmp (this->adminRole_parser_->post_boolean ());
        this->adminRole (tmp);
      }

      static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ())->adminRole = true;
      return true;
    }

    if (n == "settingsRole" && ns.empty ())
    {
      if (this->settingsRole_parser_)
      {
        this->settingsRole_parser_->pre ();
        this->settingsRole_parser_->_pre_impl ();
        this->settingsRole_parser_->_characters (s);
        this->settingsRole_parser_->_post_impl ();
        bool tmp (this->settingsRole_parser_->post_boolean ());
        this->settingsRole (tmp);
      }

      static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ())->settingsRole = true;
      return true;
    }

    if (n == "downloadRole" && ns.empty ())
    {
      if (this->downloadRole_parser_)
      {
        this->downloadRole_parser_->pre ();
        this->downloadRole_parser_->_pre_impl ();
        this->downloadRole_parser_->_characters (s);
        this->downloadRole_parser_->_post_impl ();
        bool tmp (this->downloadRole_parser_->post_boolean ());
        this->downloadRole (tmp);
      }

      static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ())->downloadRole = true;
      return true;
    }

    if (n == "uploadRole" && ns.empty ())
    {
      if (this->uploadRole_parser_)
      {
        this->uploadRole_parser_->pre ();
        this->uploadRole_parser_->_pre_impl ();
        this->uploadRole_parser_->_characters (s);
        this->uploadRole_parser_->_post_impl ();
        bool tmp (this->uploadRole_parser_->post_boolean ());
        this->uploadRole (tmp);
      }

      static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ())->uploadRole = true;
      return true;
    }

    if (n == "playlistRole" && ns.empty ())
    {
      if (this->playlistRole_parser_)
      {
        this->playlistRole_parser_->pre ();
        this->playlistRole_parser_->_pre_impl ();
        this->playlistRole_parser_->_characters (s);
        this->playlistRole_parser_->_post_impl ();
        bool tmp (this->playlistRole_parser_->post_boolean ());
        this->playlistRole (tmp);
      }

      static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ())->playlistRole = true;
      return true;
    }

    if (n == "coverArtRole" && ns.empty ())
    {
      if (this->coverArtRole_parser_)
      {
        this->coverArtRole_parser_->pre ();
        this->coverArtRole_parser_->_pre_impl ();
        this->coverArtRole_parser_->_characters (s);
        this->coverArtRole_parser_->_post_impl ();
        bool tmp (this->coverArtRole_parser_->post_boolean ());
        this->coverArtRole (tmp);
      }

      static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ())->coverArtRole = true;
      return true;
    }

    if (n == "commentRole" && ns.empty ())
    {
      if (this->commentRole_parser_)
      {
        this->commentRole_parser_->pre ();
        this->commentRole_parser_->_pre_impl ();
        this->commentRole_parser_->_characters (s);
        this->commentRole_parser_->_post_impl ();
        bool tmp (this->commentRole_parser_->post_boolean ());
        this->commentRole (tmp);
      }

      static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ())->commentRole = true;
      return true;
    }

    if (n == "podcastRole" && ns.empty ())
    {
      if (this->podcastRole_parser_)
      {
        this->podcastRole_parser_->pre ();
        this->podcastRole_parser_->_pre_impl ();
        this->podcastRole_parser_->_characters (s);
        this->podcastRole_parser_->_post_impl ();
        bool tmp (this->podcastRole_parser_->post_boolean ());
        this->podcastRole (tmp);
      }

      static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ())->podcastRole = true;
      return true;
    }

    if (n == "streamRole" && ns.empty ())
    {
      if (this->streamRole_parser_)
      {
        this->streamRole_parser_->pre ();
        this->streamRole_parser_->_pre_impl ();
        this->streamRole_parser_->_characters (s);
        this->streamRole_parser_->_post_impl ();
        bool tmp (this->streamRole_parser_->post_boolean ());
        this->streamRole (tmp);
      }

      static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ())->streamRole = true;
      return true;
    }

    if (n == "jukeboxRole" && ns.empty ())
    {
      if (this->jukeboxRole_parser_)
      {
        this->jukeboxRole_parser_->pre ();
        this->jukeboxRole_parser_->_pre_impl ();
        this->jukeboxRole_parser_->_characters (s);
        this->jukeboxRole_parser_->_post_impl ();
        bool tmp (this->jukeboxRole_parser_->post_boolean ());
        this->jukeboxRole (tmp);
      }

      static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ())->jukeboxRole = true;
      return true;
    }

    if (n == "shareRole" && ns.empty ())
    {
      if (this->shareRole_parser_)
      {
        this->shareRole_parser_->pre ();
        this->shareRole_parser_->_pre_impl ();
        this->shareRole_parser_->_characters (s);
        this->shareRole_parser_->_post_impl ();
        bool tmp (this->shareRole_parser_->post_boolean ());
        this->shareRole (tmp);
      }

      static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ())->shareRole = true;
      return true;
    }

    return false;
  }

  void User_pskel::
  _pre_a_validate ()
  {
    this->v_state_attr_stack_.push ();
    v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());

    as.username = false;
    as.scrobblingEnabled = false;
    as.adminRole = false;
    as.settingsRole = false;
    as.downloadRole = false;
    as.uploadRole = false;
    as.playlistRole = false;
    as.coverArtRole = false;
    as.commentRole = false;
    as.podcastRole = false;
    as.streamRole = false;
    as.jukeboxRole = false;
    as.shareRole = false;
  }

  void User_pskel::
  _post_a_validate ()
  {
    v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());

    if (!as.username)
      this->_expected_attribute (
        "", "username");
    if (!as.scrobblingEnabled)
      this->_expected_attribute (
        "", "scrobblingEnabled");
    if (!as.adminRole)
      this->_expected_attribute (
        "", "adminRole");
    if (!as.settingsRole)
      this->_expected_attribute (
        "", "settingsRole");
    if (!as.downloadRole)
      this->_expected_attribute (
        "", "downloadRole");
    if (!as.uploadRole)
      this->_expected_attribute (
        "", "uploadRole");
    if (!as.playlistRole)
      this->_expected_attribute (
        "", "playlistRole");
    if (!as.coverArtRole)
      this->_expected_attribute (
        "", "coverArtRole");
    if (!as.commentRole)
      this->_expected_attribute (
        "", "commentRole");
    if (!as.podcastRole)
      this->_expected_attribute (
        "", "podcastRole");
    if (!as.streamRole)
      this->_expected_attribute (
        "", "streamRole");
    if (!as.jukeboxRole)
      this->_expected_attribute (
        "", "jukeboxRole");
    if (!as.shareRole)
      this->_expected_attribute (
        "", "shareRole");

    this->v_state_attr_stack_.pop ();
  }

  // Attribute validation and dispatch functions for Error_pskel.
  //
  bool Error_pskel::
  _attribute_impl_phase_one (const ::xml_schema::ro_string& ns,
                             const ::xml_schema::ro_string& n,
                             const ::xml_schema::ro_string& s)
  {
    if (n == "code" && ns.empty ())
    {
      if (this->code_parser_)
      {
        this->code_parser_->pre ();
        this->code_parser_->_pre_impl ();
        this->code_parser_->_characters (s);
        this->code_parser_->_post_impl ();
        int tmp (this->code_parser_->post_int ());
        this->code (tmp);
      }

      static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ())->code = true;
      return true;
    }

    if (n == "message" && ns.empty ())
    {
      if (this->message_parser_)
      {
        this->message_parser_->pre ();
        this->message_parser_->_pre_impl ();
        this->message_parser_->_characters (s);
        this->message_parser_->_post_impl ();
        const ::std::string& tmp (this->message_parser_->post_string ());
        this->message (tmp);
      }

      return true;
    }

    return false;
  }

  void Error_pskel::
  _pre_a_validate ()
  {
    this->v_state_attr_stack_.push ();
    v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());

    as.code = false;
  }

  void Error_pskel::
  _post_a_validate ()
  {
    v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());

    if (!as.code)
      this->_expected_attribute (
        "", "code");

    this->v_state_attr_stack_.pop ();
  }
}

namespace restapi
{
  // Character validation functions for Genre_pskel.
  //
  bool Genre_pskel::
  _characters_impl (const ::xml_schema::ro_string& s)
  {
    this->_any_characters (s);
    return true;
  }

  // Character validation functions for Lyrics_pskel.
  //
  bool Lyrics_pskel::
  _characters_impl (const ::xml_schema::ro_string& s)
  {
    this->_any_characters (s);
    return true;
  }
}

// Begin epilogue.
//
//
// End epilogue.

